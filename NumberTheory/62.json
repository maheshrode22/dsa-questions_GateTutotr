{
    "problems": [
        {
            "id": null,
            "title": "Tree of Coprimes (Number Theory)",
            "description": "There is a tree consisting of n nodes numbered from 0 to n - 1. Each node has a value associated with it.\nReturn an array ans of size n, where ans[i] is the closest ancestor to node i such that nums[i] and nums[ans[i]] are coprime, or -1 if there is no such ancestor.\n\nInput Format:\nFirst line: integer n.\nSecond line: n space-separated integers (nums).\nNext n-1 lines: two integers u, v (edge).\n\nOutput Format:\nPrint n space-separated integers.",
            "examples": "Sample Input\n4\n2 3 3 2\n0 1\n1 2\n1 3\n\nSample Output\n-1 0 0 1",
            "constraints": "1 <= nums[i] <= 50",
            "hints": 1,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 4033,
            "difficulty": 3,
            "testCases": [
                {
                    "input": "4\n2 3 3 2\n0 1\n1 2\n1 3",
                    "expectedOutput": "-1 0 0 1"
                },
                {
                    "input": "7\n5 6 10 2 3 6 15\n0 1\n0 2\n1 3\n1 4\n2 5\n2 6",
                    "expectedOutput": "-1 0 -1 0 0 0 -1"
                },
                {
                    "input": "15\n37 31 28 24 1 41 6 26 26 31 23 26 9 22 42\n0 1\n0 2\n1 3\n2 4\n0 5\n2 6\n0 7\n7 8\n5 9\n6 10\n1 11\n10 12\n8 13\n12 14",
                    "expectedOutput": "-1 0 0 1 2 0 0 0 0 5 6 1 10 0 10"
                },
                {
                    "input": "17\n24 7 31 9 36 49 50 17 30 36 38 19 32 7 42 34 31\n0 1\n1 2\n1 3\n3 4\n0 5\n2 6\n1 7\n3 8\n3 9\n7 10\n7 11\n6 12\n3 13\n7 14\n13 15\n0 16",
                    "expectedOutput": "-1 0 1 1 1 0 2 1 1 1 7 7 2 3 7 13 0"
                },
                {
                    "input": "16\n16 28 31 24 44 2 41 4 26 44 18 41 40 14 9 26\n0 1\n1 2\n1 3\n0 4\n4 5\n4 6\n6 7\n6 8\n8 9\n7 10\n5 11\n2 12\n8 13\n3 14\n13 15",
                    "expectedOutput": "-1 -1 1 -1 -1 -1 4 6 6 6 6 5 2 6 1 6"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def getCoprimes(self, nums, edges):\n        # TODO: Return array of ancestors\n        pass\n\nif __name__ == '__main__':\n    n = int(input().strip())\n    nums = list(map(int, input().split()))\n    edges = []\n    for _ in range(n-1):\n        edges.append(list(map(int, input().split())))\n    sol = Solution()\n    print(*(sol.getCoprimes(nums, edges)))"
                },
                {
                    "language": 2,
                    "code": "import java.util.*;\n\nclass Solution {\n    public int[] getCoprimes(int[] nums, int[][] edges) {\n        // TODO: Return array of ancestors\n        return new int[0];\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n        for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n        int[][] edges = new int[n-1][2];\n        for(int i=0; i<n-1; i++) {\n            edges[i][0] = sc.nextInt();\n            edges[i][1] = sc.nextInt();\n        }\n        Solution sol = new Solution();\n        int[] res = sol.getCoprimes(nums, edges);\n        for(int i=0; i<res.length; i++) System.out.print(res[i] + (i==res.length-1?\"\":\" \"));\n        System.out.println();\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    getCoprimes(nums, edges) {\n        // TODO: Return array of ancestors\n        return [];\n    }\n}\n\nconst fs = require('fs');\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst n = Number(input[0].trim());\nconst nums = input[1].split(' ').map(Number);\nconst edges = [];\nfor(let i=2; i<=n; i++) edges.push(input[i].split(' ').map(Number));\nconst sol = new Solution();\nconsole.log(sol.getCoprimes(nums, edges).join(' '));"
                },
                {
                    "language": 4,
                    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> getCoprimes(vector<int>& nums, vector<vector<int>>& edges) {\n        // TODO: Return array of ancestors\n        return {};\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> nums(n);\n    for(int i=0; i<n; i++) cin >> nums[i];\n    vector<vector<int>> edges(n-1, vector<int>(2));\n    for(int i=0; i<n-1; i++) cin >> edges[i][0] >> edges[i][1];\n    Solution sol;\n    vector<int> res = sol.getCoprimes(nums, edges);\n    for(int i=0; i<n; i++) cout << res[i] << (i==n-1?\"\":\" \");\n    cout << endl;\n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint* getCoprimes(int* nums, int numsSize, int** edges, int edgesSize, int* edgesColSize, int* returnSize) {\n    // TODO: Return array of ancestors\n    *returnSize = numsSize;\n    return NULL;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int* nums = (int*)malloc(n * sizeof(int));\n    for(int i=0; i<n; i++) scanf(\"%d\", &nums[i]);\n    int** edges = (int**)malloc((n-1) * sizeof(int*));\n    for(int i=0; i<n-1; i++) {\n        edges[i] = (int*)malloc(2 * sizeof(int));\n        scanf(\"%d %d\", &edges[i][0], &edges[i][1]);\n    }\n    int returnSize;\n    int* res = getCoprimes(nums, n, edges, n-1, NULL, &returnSize);\n    for(int i=0; i<returnSize; i++) printf(\"%d%s\", res[i], (i==returnSize-1?\"\":\" \"));\n    printf(\"\\n\");\n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Since nums[i] <= 50, you can track the most recent ancestor for each value 1-50 during DFS."
            ]
        }
    ]
}