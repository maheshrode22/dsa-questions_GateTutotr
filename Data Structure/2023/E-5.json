{
  "problems": [

    {
      "id": null,
      "title": "Inorder Traversal of Binary Tree",
      "description": "Problem Statement\n\nGiven a binary tree, print its nodes using Inorder Traversal.\n\nInorder Traversal follows this order:\n1. Left subtree\n2. Root node\n3. Right subtree\n\nYou are given the tree represented as an array where -1 denotes a NULL node. Insert elements level-wise into the binary tree.\n\nYou need to implement:\n- A function to construct a binary tree from input array\n- A function to perform inorder traversal\n- Print elements in a single line separated by space\n\nInput Format\nThe first line contains an integer N (number of nodes)\nThe second line contains N space-separated integers representing tree level order where -1 means NULL node\n\nOutput Format\nPrint the inorder traversal of the tree. If tree is empty, print \"Tree is Empty\"\n\nExample\nInput:\n7\n1 2 3 4 5 -1 -1\n\nOutput:\n4 2 5 1 3\n\nExplanation:\nTree structure:\n      1\n     / \\\n    2   3\n   / \\\n  4   5\nInorder: Left -> Root -> Right → 4 2 5 1 3",
      "examples": "Sample Input 1\n7\n1 2 3 4 5 -1 -1\n\nSample Output 1\n4 2 5 1 3\n\nSample Input 2\n1\n10\n\nSample Output 2\n10",
      "constraints": "1 ≤ N ≤ 1000\n1 ≤ nodeValue ≤ 10^6 or -1 for NULL child",
      "hints": 2,
      "timeLimit": 5,
      "memoryLimit": 256,
      "subdomainId": 2023,
      "difficulty": 2,
      "streamId": null,
      "createdByUserId": null,
      "updatedByUserId": null,
      "testCases": [
        {
          "id": null,
          "problemId": null,
          "input": "7\n1 2 3 4 5 -1 -1",
          "expectedOutput": "4 2 5 1 3",
          "problemTitle": "Inorder Traversal of Binary Tree"
        },
        {
          "id": null,
          "problemId": null,
          "input": "1\n10",
          "expectedOutput": "10",
          "problemTitle": "Inorder Traversal of Binary Tree"
        },
        {
          "id": null,
          "problemId": null,
          "input": "5\n1 2 3 -1 4",
          "expectedOutput": "2 4 1 3",
          "problemTitle": "Inorder Traversal of Binary Tree"
        },
        {
          "id": null,
          "problemId": null,
          "input": "3\n5 -1 7",
          "expectedOutput": "5 7",
          "problemTitle": "Inorder Traversal of Binary Tree"
        },
        {
          "id": null,
          "problemId": null,
          "input": "9\n1 2 3 4 -1 -1 5 -1 -1",
          "expectedOutput": "4 2 1 3 5",
          "problemTitle": "Inorder Traversal of Binary Tree"
        }
      ],
      "starterCodes": [
        {
          "id": null,
          "problemId": null,
          "language": 1,
          "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, arr):\n        # TODO: Build binary tree from array (level order)\n        pass\n\n    def inorderTraversal(self, root):\n        # TODO: Perform inorder traversal and return elements list\n        pass\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sol = Solution()\n    root = sol.buildTree(arr)\n    result = sol.inorderTraversal(root)\n    if not result:\n        print(\"Tree is Empty\")\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
          "problemTitle": "Inorder Traversal of Binary Tree"
        },
        {
          "id": null,
          "problemId": null,
          "language": 2,
          "code": "import java.util.*;\nclass Node {\n    int data;\n    Node left, right;\n    Node(int d){ data=d; }\n}\nclass Solution {\n    Node buildTree(int[] arr){\n        // TODO: Build tree from level order\n        return null;\n    }\n    ArrayList<Integer> inorderTraversal(Node root){\n        // TODO: Inorder traversal\n        return new ArrayList<>();\n    }\n}\npublic class SolutionMain{\n    public static void main(String[] args)throws Exception{\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        int[] arr=Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Solution sol=new Solution();\n        Node root=sol.buildTree(arr);\n        ArrayList<Integer> res=sol.inorderTraversal(root);\n        if(res.isEmpty()) System.out.println(\"Tree is Empty\");\n        else System.out.println(res.toString().replaceAll(\"[\\[\\],]\", \"\"));\n    }\n}",
          "problemTitle": "Inorder Traversal of Binary Tree"
        },
        {
          "id": null,
          "problemId": null,
          "language": 3,
          "code": "class Node{\n  constructor(data){\n    this.data=data;\n    this.left=null;\n    this.right=null;\n  }\n}\nclass Solution{\n  buildTree(arr){\n    // TODO: Build tree from level order\n    return null;\n  }\n  inorderTraversal(root){\n    // TODO: Inorder traversal\n    return [];\n  }\n}\nfunction solve(input){\n  const lines=input.trim().split(\"\\n\");\n  const n=parseInt(lines[0]);\n  const arr=lines[1].split(\" \").map(Number);\n  const sol=new Solution();\n  const root=sol.buildTree(arr);\n  const res=sol.inorderTraversal(root);\n  console.log(res.length===0?\"Tree is Empty\":res.join(\" \"));\n}\nconst fs=require(\"fs\");\nsolve(fs.readFileSync(0,\"utf-8\"));",
          "problemTitle": "Inorder Traversal of Binary Tree"
        },
        {
          "id": null,
          "problemId": null,
          "language": 4,
          "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node{\n    int data;\n    Node* left;\n    Node* right;\n    Node(int d){ data=d; left=right=NULL; }\n};\nclass Solution{\npublic:\n    Node* buildTree(vector<int>& arr){\n        // TODO: Build tree from level order\n        return NULL;\n    }\n    vector<int> inorderTraversal(Node* root){\n        // TODO: inorder traversal\n        return {};\n    }\n};\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n; cin>>n;\n    vector<int> arr(n);\n    for(int i=0;i<n;i++) cin>>arr[i];\n    Solution sol;\n    Node* root=sol.buildTree(arr);\n    vector<int> res=sol.inorderTraversal(root);\n    if(res.empty()) cout<<\"Tree is Empty\";\n    else{\n        for(int i=0;i<res.size();i++){\n            cout<<res[i];\n            if(i<res.size()-1) cout<<\" \";\n        }\n    }\n}",
          "problemTitle": "Inorder Traversal of Binary Tree"
        },
        {
          "id": null,
          "problemId": null,
          "language": 5,
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node{\n    int data;\n    struct Node* left;\n    struct Node* right;\n}Node;\n\nNode* buildTree(int arr[], int n){\n    // TODO: Build tree level order\n    return NULL;\n}\n\nvoid inorder(Node* root){\n    // TODO: Inorder traversal\n}\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    int arr[n];\n    for(int i=0;i<n;i++) scanf(\"%d\",&arr[i]);\n    Node* root=buildTree(arr,n);\n    if(!root){ printf(\"Tree is Empty\"); return 0; }\n    inorder(root);\n    return 0;\n}",
          "problemTitle": "Inorder Traversal of Binary Tree"
        }
      ],
      "hintsList": [
        "Inorder Traversal = Left → Root → Right.",
        "Use recursion or a stack to traverse tree nodes in order."
      ]
    }
,
{
  "id": null,
  "title": "Preorder Traversal of Binary Tree",
  "description": "Problem Statement\n\nGiven a binary tree, print its nodes using Preorder Traversal.\n\nPreorder Traversal follows this order:\n1. Root node\n2. Left subtree\n3. Right subtree\n\nYou are given the tree represented as an array where -1 denotes a NULL node. Insert elements level-wise into the binary tree.\n\nYou need to implement:\n- A function to construct the binary tree from input array\n- A function to perform preorder traversal\n- Print elements in a single line separated by space\n\nInput Format\nThe first line contains an integer N (number of nodes)\nThe second line contains N space-separated integers representing tree level order where -1 means NULL node\n\nOutput Format\nPrint the preorder traversal of the tree. If tree is empty, print \"Tree is Empty\"\n\nExample\nInput:\n7\n1 2 3 4 5 -1 -1\n\nOutput:\n1 2 4 5 3\n\nExplanation:\nTree:\n      1\n     / \\\n    2   3\n   / \\\n  4   5\nPreorder: Root → Left → Right → 1 2 4 5 3",
  "examples": "Sample Input 1\n7\n1 2 3 4 5 -1 -1\n\nSample Output 1\n1 2 4 5 3\n\nSample Input 2\n1\n10\n\nSample Output 2\n10",
  "constraints": "1 ≤ N ≤ 1000\n1 ≤ nodeValue ≤ 10^6 or -1 for NULL",
  "hints": 2,
  "timeLimit": 5,
  "memoryLimit": 256,
  "subdomainId": 2023,
  "difficulty": 2,
  "streamId": null,
  "createdByUserId": null,
  "updatedByUserId": null,
  "testCases": [
    {
      "id": null,
      "problemId": null,
      "input": "7\n1 2 3 4 5 -1 -1",
      "expectedOutput": "1 2 4 5 3",
      "problemTitle": "Preorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "1\n10",
      "expectedOutput": "10",
      "problemTitle": "Preorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "5\n1 2 3 -1 4",
      "expectedOutput": "1 2 4 3",
      "problemTitle": "Preorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "3\n5 -1 7",
      "expectedOutput": "5 7",
      "problemTitle": "Preorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "9\n1 2 3 4 -1 -1 5 -1 -1",
      "expectedOutput": "1 2 4 3 5",
      "problemTitle": "Preorder Traversal of Binary Tree"
    }
  ],
  "starterCodes": [
    {
      "id": null,
      "problemId": null,
      "language": 1,
      "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, arr):\n        # TODO: Build binary tree from array (level order)\n        pass\n\n    def preorderTraversal(self, root):\n        # TODO: Perform preorder traversal and return list\n        pass\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sol = Solution()\n    root = sol.buildTree(arr)\n    result = sol.preorderTraversal(root)\n    if not result:\n        print(\"Tree is Empty\")\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
      "problemTitle": "Preorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 2,
      "code": "import java.util.*;\nclass Node{\n    int data;\n    Node left,right;\n    Node(int d){ data=d; }\n}\nclass Solution{\n    Node buildTree(int[] arr){\n        // TODO: Build tree from level order\n        return null;\n    }\n    ArrayList<Integer> preorderTraversal(Node root){\n        // TODO: Preorder traversal\n        return new ArrayList<>();\n    }\n}\npublic class SolutionMain{\n    public static void main(String[] args)throws Exception{\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        int[] arr=Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Solution sol=new Solution();\n        Node root=sol.buildTree(arr);\n        ArrayList<Integer> res=sol.preorderTraversal(root);\n        if(res.isEmpty()) System.out.println(\"Tree is Empty\");\n        else System.out.println(res.toString().replaceAll(\"[\\\\[\\\\],]\",\"\"));\n    }\n}",
      "problemTitle": "Preorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 3,
      "code": "class Node{\n  constructor(data){ this.data=data; this.left=null; this.right=null; }\n}\nclass Solution{\n  buildTree(arr){\n    // TODO: Build tree\n    return null;\n  }\n  preorderTraversal(root){\n    // TODO: Preorder traversal\n    return [];\n  }\n}\nfunction solve(input){\n  const lines=input.trim().split(\"\\n\");\n  const n=parseInt(lines[0]);\n  const arr=lines[1].split(\" \").map(Number);\n  const sol=new Solution();\n  const root=sol.buildTree(arr);\n  const res=sol.preorderTraversal(root);\n  console.log(res.length===0?\"Tree is Empty\":res.join(\" \"));\n}\nconst fs=require(\"fs\");\nsolve(fs.readFileSync(0,\"utf-8\"));",
      "problemTitle": "Preorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 4,
      "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node{\n    int data;\n    Node* left;\n    Node* right;\n    Node(int d){ data=d; left=right=NULL; }\n};\nclass Solution{\npublic:\n    Node* buildTree(vector<int>& arr){\n        // TODO: Build tree\n        return NULL;\n    }\n    vector<int> preorderTraversal(Node* root){\n        // TODO: preorder\n        return {};\n    }\n};\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n; cin>>n;\n    vector<int> arr(n);\n    for(int i=0;i<n;i++) cin>>arr[i];\n    Solution sol;\n    Node* root=sol.buildTree(arr);\n    vector<int> res=sol.preorderTraversal(root);\n    if(res.empty()) cout<<\"Tree is Empty\";\n    else{\n        for(int i=0;i<res.size();i++){\n            cout<<res[i]; if(i<res.size()-1) cout<<\" \";\n        }\n    }\n}",
      "problemTitle": "Preorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 5,
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node{\n    int data;\n    struct Node* left;\n    struct Node* right;\n}Node;\n\nNode* buildTree(int arr[], int n){\n    // TODO: Build tree\n    return NULL;\n}\n\nvoid preorder(Node* root){\n    // TODO: preorder\n}\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    int arr[n];\n    for(int i=0;i<n;i++) scanf(\"%d\",&arr[i]);\n    Node* root=buildTree(arr,n);\n    if(!root){ printf(\"Tree is Empty\"); return 0; }\n    preorder(root);\n    return 0;\n}",
      "problemTitle": "Preorder Traversal of Binary Tree"
    }
  ],
  "hintsList": [
    "Preorder = Root → Left → Right.",
    "Use recursion to first print the node, then traverse left and right subtrees."
  ]
},
{
  "id": null,
  "title": "Postorder Traversal of Binary Tree",
  "description": "Problem Statement\n\nGiven a binary tree, print its nodes using Postorder Traversal.\n\nPostorder Traversal follows this order:\n1. Left subtree\n2. Right subtree\n3. Root node\n\nYou are given the binary tree as a level-order array where -1 represents a NULL node. The tree must be built level-wise.\n\nYou need to implement:\n- Function to construct binary tree from the array\n- Function to perform postorder traversal\n- Print values in one line separated by spaces\n\nInput Format\nThe first line contains an integer N (number of nodes).\nThe second line contains N space-separated integers representing level-order traversal, where -1 denotes a missing (NULL) node.\n\nOutput Format\nPrint the postorder traversal of the tree. If the tree is empty, print \"Tree is Empty\".\n\nExample\nInput:\n7\n1 2 3 4 5 -1 -1\n\nOutput:\n4 5 2 3 1\n\nExplanation:\n      1\n     / \\\n    2   3\n   / \\\n  4   5\nPostorder: Left → Right → Root → 4 5 2 3 1",
  "examples": "Sample Input 1\n7\n1 2 3 4 5 -1 -1\n\nSample Output 1\n4 5 2 3 1\n\nSample Input 2\n1\n10\n\nSample Output 2\n10",
  "constraints": "1 ≤ N ≤ 1000\nNode value: 1 ≤ value ≤ 10^6 or -1 for NULL",
  "hints": 2,
  "timeLimit": 5,
  "memoryLimit": 256,
  "subdomainId": 2023,
  "difficulty": 2,
  "streamId": null,
  "createdByUserId": null,
  "updatedByUserId": null,
  "testCases": [
    {
      "id": null,
      "problemId": null,
      "input": "7\n1 2 3 4 5 -1 -1",
      "expectedOutput": "4 5 2 3 1",
      "problemTitle": "Postorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "1\n10",
      "expectedOutput": "10",
      "problemTitle": "Postorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "5\n1 2 3 -1 4",
      "expectedOutput": "4 2 3 1",
      "problemTitle": "Postorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "3\n5 -1 7",
      "expectedOutput": "7 5",
      "problemTitle": "Postorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "9\n1 2 3 4 -1 -1 5 -1 -1",
      "expectedOutput": "4 2 5 3 1",
      "problemTitle": "Postorder Traversal of Binary Tree"
    }
  ],
  "starterCodes": [
    {
      "id": null,
      "problemId": null,
      "language": 1,
      "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, arr):\n        # TODO: Build binary tree from array (level order)\n        pass\n\n    def postorderTraversal(self, root):\n        # TODO: Perform postorder traversal (Left → Right → Root)\n        pass\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sol = Solution()\n    root = sol.buildTree(arr)\n    result = sol.postorderTraversal(root)\n    if not result:\n        print(\"Tree is Empty\")\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
      "problemTitle": "Postorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 2,
      "code": "import java.util.*;\nclass Node{\n    int data; Node left,right;\n    Node(int d){ data=d; }\n}\nclass Solution{\n    Node buildTree(int[] arr){\n        // TODO: Build tree (level order)\n        return null;\n    }\n    ArrayList<Integer> postorderTraversal(Node root){\n        // TODO: postorder\n        return new ArrayList<>();\n    }\n}\npublic class SolutionMain{\n    public static void main(String[] args)throws Exception{\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        int[] arr=Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Solution sol=new Solution();\n        Node root=sol.buildTree(arr);\n        ArrayList<Integer> res=sol.postorderTraversal(root);\n        if(res.isEmpty()) System.out.println(\"Tree is Empty\");\n        else System.out.println(res.toString().replaceAll(\"[\\\\[\\\\],]\",\"\"));\n    }\n}",
      "problemTitle": "Postorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 3,
      "code": "class Node{\n  constructor(data){ this.data=data; this.left=null; this.right=null; }\n}\nclass Solution{\n  buildTree(arr){\n    // TODO: Build tree\n    return null;\n  }\n  postorderTraversal(root){\n    // TODO: Postorder\n    return [];\n  }\n}\nfunction solve(input){\n  const lines=input.trim().split(\"\\n\");\n  const n=parseInt(lines[0]);\n  const arr=lines[1].split(\" \").map(Number);\n  const sol=new Solution();\n  const root=sol.buildTree(arr);\n  const res=sol.postorderTraversal(root);\n  console.log(res.length===0?\"Tree is Empty\":res.join(\" \"));\n}\nconst fs=require(\"fs\");\nsolve(fs.readFileSync(0,\"utf-8\"));",
      "problemTitle": "Postorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 4,
      "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node{\n    int data; Node* left; Node* right;\n    Node(int d){ data=d; left=right=NULL; }\n};\nclass Solution{\npublic:\n    Node* buildTree(vector<int>& arr){\n        // TODO: Build tree\n        return NULL;\n    }\n    vector<int> postorderTraversal(Node* root){\n        // TODO: Postorder\n        return {};\n    }\n};\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n; cin>>n;\n    vector<int> arr(n);\n    for(int i=0;i<n;i++) cin>>arr[i];\n    Solution sol;\n    Node* root=sol.buildTree(arr);\n    vector<int> res=sol.postorderTraversal(root);\n    if(res.empty()) cout<<\"Tree is Empty\";\n    else{\n        for(int i=0;i<res.size();i++){\n            cout<<res[i]; if(i<res.size()-1) cout<<\" \";\n        }\n    }\n}",
      "problemTitle": "Postorder Traversal of Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 5,
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node{\n    int data;\n    struct Node* left;\n    struct Node* right;\n}Node;\n\nNode* buildTree(int arr[], int n){\n    // TODO: Build tree\n    return NULL;\n}\n\nvoid postorder(Node* root){\n    // TODO: Postorder\n}\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    int arr[n];\n    for(int i=0;i<n;i++) scanf(\"%d\",&arr[i]);\n    Node* root=buildTree(arr,n);\n    if(!root){ printf(\"Tree is Empty\"); return 0; }\n    postorder(root);\n    return 0;\n}",
      "problemTitle": "Postorder Traversal of Binary Tree"
    }
  ],
  "hintsList": [
    "Postorder = Left → Right → Root.",
    "Use recursion to visit children first, then process the node."
  ]
}
,
{
  "id": null,
  "title": "Count Leaf Nodes in a Binary Tree",
  "description": "Problem Statement\n\nGiven a binary tree, count the total number of leaf nodes.\n\nA leaf node is a node that has:\n- No left child\n- No right child\n\nYou are given the binary tree in level-order array format, where -1 represents a NULL node.\n\nYou need to implement:\n- A function to construct the binary tree from the array\n- A function to count all leaf nodes\n\nInput Format\nThe first line contains an integer N (number of nodes in the level order array).\nThe second line contains N space-separated integers representing the tree in level-order. -1 represents a NULL node.\n\nOutput Format\nPrint the total number of leaf nodes. If the tree is empty, print \"Tree is Empty\".\n\nExample\nInput:\n7\n1 2 3 4 5 -1 -1\n\nOutput:\n2\n\nExplanation:\nLeaf nodes = 4, 5 → total = 2",
  "examples": "Sample Input 1\n7\n1 2 3 4 5 -1 -1\n\nSample Output 1\n2\n\nSample Input 2\n1\n10\n\nSample Output 2\n1",
  "constraints": "1 ≤ N ≤ 1000\nNode value: 1 ≤ value ≤ 10^6 or -1 for NULL",
  "hints": 2,
  "timeLimit": 5,
  "memoryLimit": 256,
  "subdomainId": 2023,
  "difficulty": 1,
  "streamId": null,
  "createdByUserId": null,
  "updatedByUserId": null,
  "testCases": [
    {
      "id": null,
      "problemId": null,
      "input": "7\n1 2 3 4 5 -1 -1",
      "expectedOutput": "2",
      "problemTitle": "Count Leaf Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "1\n10",
      "expectedOutput": "1",
      "problemTitle": "Count Leaf Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "5\n1 2 -1 -1 -1",
      "expectedOutput": "1",
      "problemTitle": "Count Leaf Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "3\n5 -1 7",
      "expectedOutput": "1",
      "problemTitle": "Count Leaf Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "9\n1 2 3 4 -1 6 7 -1 -1",
      "expectedOutput": "4",
      "problemTitle": "Count Leaf Nodes in a Binary Tree"
    }
  ],
  "starterCodes": [
    {
      "id": null,
      "problemId": null,
      "language": 1,
      "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, arr):\n        # TODO: Build binary tree from array (level order)\n        pass\n\n    def countLeafNodes(self, root):\n        # TODO: Count nodes with no children\n        pass\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sol = Solution()\n    root = sol.buildTree(arr)\n    if root is None:\n        print(\"Tree is Empty\")\n        return\n    result = sol.countLeafNodes(root)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "problemTitle": "Count Leaf Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 2,
      "code": "import java.util.*;\nclass Node{\n    int data; Node left,right;\n    Node(int d){ data=d; }\n}\nclass Solution{\n    Node buildTree(int[] arr){\n        // TODO: Build tree\n        return null;\n    }\n    int countLeafNodes(Node root){\n        // TODO: Count leaf nodes\n        return 0;\n    }\n}\npublic class SolutionMain{\n    public static void main(String[] args)throws Exception{\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        int[] arr=Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Solution sol=new Solution();\n        Node root=sol.buildTree(arr);\n        if(root==null){ System.out.println(\"Tree is Empty\"); return; }\n        System.out.println(sol.countLeafNodes(root));\n    }\n}",
      "problemTitle": "Count Leaf Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 3,
      "code": "class Node{\n  constructor(data){ this.data=data; this.left=null; this.right=null; }\n}\nclass Solution{\n  buildTree(arr){\n    // TODO: Build tree\n    return null;\n  }\n  countLeafNodes(root){\n    // TODO: Count leaf nodes\n    return 0;\n  }\n}\nfunction solve(input){\n  const lines=input.trim().split(\"\\n\");\n  const n=parseInt(lines[0]);\n  const arr=lines[1].split(\" \").map(Number);\n  const sol=new Solution();\n  const root=sol.buildTree(arr);\n  if(!root){ console.log(\"Tree is Empty\"); return; }\n  console.log(sol.countLeafNodes(root));\n}\nconst fs=require(\"fs\");\nsolve(fs.readFileSync(0,\"utf-8\"));",
      "problemTitle": "Count Leaf Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 4,
      "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node{\n    int data; Node* left; Node* right;\n    Node(int d){ data=d; left=right=NULL; }\n};\nclass Solution{\npublic:\n    Node* buildTree(vector<int>& arr){\n        // TODO: Build tree\n        return NULL;\n    }\n    int countLeafNodes(Node* root){\n        // TODO: Count leaves\n        return 0;\n    }\n};\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n; cin>>n;\n    vector<int> arr(n);\n    for(int i=0;i<n;i++) cin>>arr[i];\n    Solution sol;\n    Node* root=sol.buildTree(arr);\n    if(!root){ cout<<\"Tree is Empty\"; return 0; }\n    cout<<sol.countLeafNodes(root);\n}",
      "problemTitle": "Count Leaf Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 5,
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node{\n    int data;\n    struct Node* left;\n    struct Node* right;\n}Node;\n\nNode* buildTree(int arr[], int n){\n    // TODO: Build tree\n    return NULL;\n}\n\nint countLeafNodes(Node* root){\n    // TODO: Count leaves\n    return 0;\n}\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    int arr[n];\n    for(int i=0;i<n;i++) scanf(\"%d\",&arr[i]);\n    Node* root=buildTree(arr,n);\n    if(!root){ printf(\"Tree is Empty\"); return 0; }\n    printf(\"%d\", countLeafNodes(root));\n    return 0;\n}",
      "problemTitle": "Count Leaf Nodes in a Binary Tree"
    }
  ],
  "hintsList": [
    "A leaf node is a node with no left child and no right child.",
    "Use DFS or recursion: if both children are NULL, count this node."
  ]
}
,{
  "id": null,
  "title": "Count Total Nodes in a Binary Tree",
  "description": "Problem Statement\n\nGiven a binary tree, count the total number of nodes.\n\nA node is counted if it exists (i.e., its value is not -1). The tree is provided as a level-order array, where -1 represents a NULL node.\n\nYou need to implement:\n- A function to build the binary tree from the array input\n- A function to count all nodes in the tree\n\nInput Format\nThe first line contains an integer N (number of elements in the level-order array).\nThe second line contains N space-separated integers, where -1 represents a NULL node.\n\nOutput Format\nPrint the total number of nodes in the tree. If the tree is empty, print \"Tree is Empty\".\n\nExample\nInput:\n7\n1 2 3 4 5 -1 -1\n\nOutput:\n5\n\nExplanation:\nNodes present: 1, 2, 3, 4, 5 → total = 5",
  "examples": "Sample Input 1\n7\n1 2 3 4 5 -1 -1\n\nSample Output 1\n5\n\nSample Input 2\n1\n10\n\nSample Output 2\n1",
  "constraints": "1 ≤ N ≤ 1000\nNode value: 1 ≤ value ≤ 10^6 or -1 for NULL",
  "hints": 2,
  "timeLimit": 5,
  "memoryLimit": 256,
  "subdomainId": 2023,
  "difficulty": 1,
  "streamId": null,
  "createdByUserId": null,
  "updatedByUserId": null,
  "testCases": [
    {
      "id": null,
      "problemId": null,
      "input": "7\n1 2 3 4 5 -1 -1",
      "expectedOutput": "5",
      "problemTitle": "Count Total Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "1\n10",
      "expectedOutput": "1",
      "problemTitle": "Count Total Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "5\n1 -1 3 -1 -1",
      "expectedOutput": "2",
      "problemTitle": "Count Total Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "3\n5 -1 7",
      "expectedOutput": "2",
      "problemTitle": "Count Total Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "input": "9\n1 2 3 4 -1 6 7 -1 -1",
      "expectedOutput": "6",
      "problemTitle": "Count Total Nodes in a Binary Tree"
    }
  ],
  "starterCodes": [
    {
      "id": null,
      "problemId": null,
      "language": 1,
      "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, arr):\n        # TODO: Build binary tree from array (level order)\n        pass\n\n    def countTotalNodes(self, root):\n        # TODO: Count all non-null nodes\n        pass\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sol = Solution()\n    root = sol.buildTree(arr)\n    if root is None:\n        print(\"Tree is Empty\")\n        return\n    result = sol.countTotalNodes(root)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "problemTitle": "Count Total Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 2,
      "code": "import java.util.*;\nclass Node{\n    int data; Node left,right;\n    Node(int d){ data=d; }\n}\nclass Solution{\n    Node buildTree(int[] arr){\n        // TODO: Build tree (level order)\n        return null;\n    }\n    int countTotalNodes(Node root){\n        // TODO: Count nodes\n        return 0;\n    }\n}\npublic class SolutionMain{\n    public static void main(String[] args)throws Exception{\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(br.readLine());\n        int[] arr=Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Solution sol=new Solution();\n        Node root=sol.buildTree(arr);\n        if(root==null){ System.out.println(\"Tree is Empty\"); return; }\n        System.out.println(sol.countTotalNodes(root));\n    }\n}",
      "problemTitle": "Count Total Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 3,
      "code": "class Node{\n  constructor(data){ this.data=data; this.left=null; this.right=null; }\n}\nclass Solution{\n  buildTree(arr){\n    // TODO: Build tree\n    return null;\n  }\n  countTotalNodes(root){\n    // TODO: Count nodes\n    return 0;\n  }\n}\nfunction solve(input){\n  const lines=input.trim().split(\"\\n\");\n  const n=parseInt(lines[0]);\n  const arr=lines[1].split(\" \").map(Number);\n  const sol=new Solution();\n  const root=sol.buildTree(arr);\n  if(!root){ console.log(\"Tree is Empty\"); return; }\n  console.log(sol.countTotalNodes(root));\n}\nconst fs=require(\"fs\");\nsolve(fs.readFileSync(0,\"utf-8\"));",
      "problemTitle": "Count Total Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 4,
      "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node{\n    int data; Node* left; Node* right;\n    Node(int d){ data=d; left=right=NULL; }\n};\nclass Solution{\npublic:\n    Node* buildTree(vector<int>& arr){\n        // TODO: Build tree\n        return NULL;\n    }\n    int countTotalNodes(Node* root){\n        // TODO: Count nodes\n        return 0;\n    }\n};\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n; cin>>n;\n    vector<int> arr(n);\n    for(int i=0;i<n;i++) cin>>arr[i];\n    Solution sol;\n    Node* root=sol.buildTree(arr);\n    if(!root){ cout<<\"Tree is Empty\"; return 0; }\n    cout<<sol.countTotalNodes(root);\n}",
      "problemTitle": "Count Total Nodes in a Binary Tree"
    },
    {
      "id": null,
      "problemId": null,
      "language": 5,
      "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node{\n    int data;\n    struct Node* left;\n    struct Node* right;\n}Node;\n\nNode* buildTree(int arr[], int n){\n    // TODO: Build tree\n    return NULL;\n}\n\nint countTotalNodes(Node* root){\n    // TODO: Count nodes\n    return 0;\n}\n\nint main(){\n    int n; scanf(\"%d\",&n);\n    int arr[n];\n    for(int i=0;i<n;i++) scanf(\"%d\",&arr[i]);\n    Node* root=buildTree(arr,n);\n    if(!root){ printf(\"Tree is Empty\"); return 0; }\n    printf(\"%d\", countTotalNodes(root));\n    return 0;\n}",
      "problemTitle": "Count Total Nodes in a Binary Tree"
    }
  ],
  "hintsList": [
    "Every node that is not NULL counts as a node.",
    "Use recursion: total = leftCount + rightCount + 1."
  ]
}



  ]
}
