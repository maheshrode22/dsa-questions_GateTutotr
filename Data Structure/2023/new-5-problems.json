{
    "problems": [
        {
            "id": null,
            "title": "Find Height of Binary Tree",
            "description": "Problem Statement\n\nGiven a binary tree, find its height (also called depth).\n\nThe height of a binary tree is the number of edges on the longest path from the root node to a leaf node.\n\nDefinition:\n- Height of an empty tree is -1\n- Height of a tree with only root is 0\n- Height = 1 + max(height of left subtree, height of right subtree)\n\nYou are given the tree in level-order array format where -1 represents NULL.\n\nInput Format\nThe first line contains an integer N (number of elements).\nThe second line contains N space-separated integers representing level-order tree, where -1 means NULL.\n\nOutput Format\nPrint the height of the tree. If tree is empty, print \"Tree is Empty\".\n\nExample\nInput:\n7\n1 2 3 4 5 -1 -1\n\nOutput:\n2\n\nExplanation:\nTree structure:\n      1        (level 0)\n     / \\\n    2   3      (level 1)\n   / \\\n  4   5        (level 2)\nHeight = 2",
            "examples": "Sample Input 1\n7\n1 2 3 4 5 -1 -1\n\nSample Output 1\n2\n\nSample Input 2\n1\n10\n\nSample Output 2\n0",
            "constraints": "1 ≤ N ≤ 1000\n1 ≤ nodeValue ≤ 10^6 or -1 for NULL",
            "hints": 2,
            "timeLimit": 5,
            "memoryLimit": 256,
            "difficulty": 2,
            "subdomainId": 2023,
            "streamId": null,
            "testCases": [
                {
                    "input": "7\n1 2 3 4 5 -1 -1",
                    "expectedOutput": "2",
                    "problemTitle": "Find Height of Binary Tree"
                },
                {
                    "input": "1\n10",
                    "expectedOutput": "0",
                    "problemTitle": "Find Height of Binary Tree"
                },
                {
                    "input": "3\n1 2 -1",
                    "expectedOutput": "1",
                    "problemTitle": "Find Height of Binary Tree"
                },
                {
                    "input": "5\n1 2 3 -1 4",
                    "expectedOutput": "2",
                    "problemTitle": "Find Height of Binary Tree"
                },
                {
                    "input": "15\n1 2 3 4 5 6 7 8 -1 -1 -1 -1 -1 -1 -1",
                    "expectedOutput": "3",
                    "problemTitle": "Find Height of Binary Tree"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, arr):\n        # TODO: Build binary tree from level order array\n        pass\n\n    def findHeight(self, root):\n        # TODO: Find height of tree\n        pass\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sol = Solution()\n    root = sol.buildTree(arr)\n    if root is None:\n        print(\"Tree is Empty\")\n        return\n    result = sol.findHeight(root)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
                    "problemTitle": "Find Height of Binary Tree"
                },
                {
                    "language": 2,
                    "code": "import java.util.*;\nclass Node {\n    int data;\n    Node left, right;\n    Node(int d) { data = d; }\n}\nclass Solution {\n    Node buildTree(int[] arr) {\n        // TODO: Build tree from level order\n        return null;\n    }\n    int findHeight(Node root) {\n        // TODO: Find height\n        return 0;\n    }\n}\npublic class SolutionMain {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Solution sol = new Solution();\n        Node root = sol.buildTree(arr);\n        if (root == null) {\n            System.out.println(\"Tree is Empty\");\n            return;\n        }\n        System.out.println(sol.findHeight(root));\n    }\n}",
                    "problemTitle": "Find Height of Binary Tree"
                },
                {
                    "language": 3,
                    "code": "class Node {\n  constructor(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n  }\n}\nclass Solution {\n  buildTree(arr) {\n    // TODO: Build tree\n    return null;\n  }\n  findHeight(root) {\n    // TODO: Find height\n    return 0;\n  }\n}\nfunction solve(input) {\n  const lines = input.trim().split(\"\\n\");\n  const n = parseInt(lines[0]);\n  const arr = lines[1].split(\" \").map(Number);\n  const sol = new Solution();\n  const root = sol.buildTree(arr);\n  if (!root) {\n    console.log(\"Tree is Empty\");\n    return;\n  }\n  console.log(sol.findHeight(root));\n}\nconst fs = require(\"fs\");\nsolve(fs.readFileSync(0, \"utf-8\"));",
                    "problemTitle": "Find Height of Binary Tree"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    Node(int d) { data = d; left = right = NULL; }\n};\nclass Solution {\npublic:\n    Node* buildTree(vector<int>& arr) {\n        // TODO: Build tree\n        return NULL;\n    }\n    int findHeight(Node* root) {\n        // TODO: Find height\n        return 0;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    Solution sol;\n    Node* root = sol.buildTree(arr);\n    if (!root) {\n        cout << \"Tree is Empty\";\n        return 0;\n    }\n    cout << sol.findHeight(root);\n}",
                    "problemTitle": "Find Height of Binary Tree"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* buildTree(int arr[], int n) {\n    // TODO: Build tree\n    return NULL;\n}\n\nint findHeight(Node* root) {\n    // TODO: Find height\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int arr[n];\n    for (int i = 0; i < n; i++) scanf(\"%d\", &arr[i]);\n    Node* root = buildTree(arr, n);\n    if (!root) {\n        printf(\"Tree is Empty\");\n        return 0;\n    }\n    printf(\"%d\", findHeight(root));\n    return 0;\n}",
                    "problemTitle": "Find Height of Binary Tree"
                }
            ],
            "hintsList": [
                "Height = maximum depth. Use recursion to find max of left and right subtree heights.",
                "Base case: if node is NULL, return -1. Otherwise return 1 + max(leftHeight, rightHeight)."
            ]
        },
        {
            "id": null,
            "title": "Level Order Traversal of Binary Tree",
            "description": "Problem Statement\n\nGiven a binary tree, print its level order traversal (also called BFS).\n\nLevel order means visiting nodes level by level from left to right.\n\nYou are given the tree in level-order array format where -1 represents NULL.\n\nInput Format\nThe first line contains N (number of elements).\nThe second line contains N space-separated integers where -1 means NULL.\n\nOutput Format\nPrint the level order traversal in one line, space-separated. If tree is empty, print \"Tree is Empty\".\n\nExample\nInput:\n7\n1 2 3 4 5 -1 -1\n\nOutput:\n1 2 3 4 5\n\nExplanation:\nLevel 0: 1\nLevel 1: 2 3\nLevel 2: 4 5\nOutput: 1 2 3 4 5",
            "examples": "Sample Input\n7\n1 2 3 4 5 -1 -1\n\nSample Output\n1 2 3 4 5",
            "constraints": "1 ≤ N ≤ 1000\n1 ≤ nodeValue ≤ 10^6 or -1 for NULL",
            "hints": 2,
            "timeLimit": 5,
            "memoryLimit": 256,
            "difficulty": 2,
            "subdomainId": 2023,
            "streamId": null,
            "testCases": [
                {
                    "input": "7\n1 2 3 4 5 -1 -1",
                    "expectedOutput": "1 2 3 4 5",
                    "problemTitle": "Level Order Traversal of Binary Tree"
                },
                {
                    "input": "1\n10",
                    "expectedOutput": "10",
                    "problemTitle": "Level Order Traversal of Binary Tree"
                },
                {
                    "input": "3\n1 2 3",
                    "expectedOutput": "1 2 3",
                    "problemTitle": "Level Order Traversal of Binary Tree"
                },
                {
                    "input": "5\n1 -1 3 -1 4",
                    "expectedOutput": "1 3 4",
                    "problemTitle": "Level Order Traversal of Binary Tree"
                },
                {
                    "input": "9\n1 2 3 4 -1 6 7 -1 -1",
                    "expectedOutput": "1 2 3 4 6 7",
                    "problemTitle": "Level Order Traversal of Binary Tree"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, arr):\n        # TODO: Build binary tree\n        pass\n\n    def levelOrderTraversal(self, root):\n        # TODO: Level order traversal using queue\n        pass\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sol = Solution()\n    root = sol.buildTree(arr)\n    if root is None:\n        print(\"Tree is Empty\")\n        return\n    result = sol.levelOrderTraversal(root)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
                    "problemTitle": "Level Order Traversal of Binary Tree"
                },
                {
                    "language": 2,
                    "code": "import java.util.*;\nclass Node {\n    int data;\n    Node left, right;\n    Node(int d) { data = d; }\n}\nclass Solution {\n    Node buildTree(int[] arr) {\n        // TODO: Build tree\n        return null;\n    }\n    ArrayList<Integer> levelOrderTraversal(Node root) {\n        // TODO: BFS traversal\n        return new ArrayList<>();\n    }\n}\npublic class SolutionMain {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Solution sol = new Solution();\n        Node root = sol.buildTree(arr);\n        if (root == null) {\n            System.out.println(\"Tree is Empty\");\n            return;\n        }\n        ArrayList<Integer> res = sol.levelOrderTraversal(root);\n        System.out.println(res.toString().replaceAll(\"[\\\\[\\\\],]\", \"\"));\n    }\n}",
                    "problemTitle": "Level Order Traversal of Binary Tree"
                },
                {
                    "language": 3,
                    "code": "class Node {\n  constructor(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n  }\n}\nclass Solution {\n  buildTree(arr) {\n    // TODO: Build tree\n    return null;\n  }\n  levelOrderTraversal(root) {\n    // TODO: BFS\n    return [];\n  }\n}\nfunction solve(input) {\n  const lines = input.trim().split(\"\\n\");\n  const n = parseInt(lines[0]);\n  const arr = lines[1].split(\" \").map(Number);\n  const sol = new Solution();\n  const root = sol.buildTree(arr);\n  if (!root) {\n    console.log(\"Tree is Empty\");\n    return;\n  }\n  const res = sol.levelOrderTraversal(root);\n  console.log(res.join(\" \"));\n}\nconst fs = require(\"fs\");\nsolve(fs.readFileSync(0, \"utf-8\"));",
                    "problemTitle": "Level Order Traversal of Binary Tree"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    Node(int d) { data = d; left = right = NULL; }\n};\nclass Solution {\npublic:\n    Node* buildTree(vector<int>& arr) {\n        // TODO: Build tree\n        return NULL;\n    }\n    vector<int> levelOrderTraversal(Node* root) {\n        // TODO: BFS\n        return {};\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    Solution sol;\n    Node* root = sol.buildTree(arr);\n    if (!root) {\n        cout << \"Tree is Empty\";\n        return 0;\n    }\n    vector<int> res = sol.levelOrderTraversal(root);\n    for (int i = 0; i < res.size(); i++) {\n        cout << res[i];\n        if (i < res.size() - 1) cout << \" \";\n    }\n}",
                    "problemTitle": "Level Order Traversal of Binary Tree"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* buildTree(int arr[], int n) {\n    // TODO: Build tree\n    return NULL;\n}\n\nvoid levelOrderTraversal(Node* root) {\n    // TODO: BFS traversal\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int arr[n];\n    for (int i = 0; i < n; i++) scanf(\"%d\", &arr[i]);\n    Node* root = buildTree(arr, n);\n    if (!root) {\n        printf(\"Tree is Empty\");\n        return 0;\n    }\n    levelOrderTraversal(root);\n    return 0;\n}",
                    "problemTitle": "Level Order Traversal of Binary Tree"
                }
            ],
            "hintsList": [
                "Use a queue. Start with root, then for each node, add its children to queue and process in order.",
                "BFS: Enqueue root, then while queue not empty, dequeue node, print it, enqueue left and right children."
            ]
        },
        {
            "id": null,
            "title": "Check if Two Trees are Identical",
            "description": "Problem Statement\n\nGiven two binary trees, check if they are identical.\n\nTwo trees are identical if:\n1. They have the same structure\n2. Corresponding nodes have the same values\n\nYou are given two trees in level-order array format where -1 represents NULL.\n\nInput Format\nThe first line contains N1 (number of elements in first tree).\nThe second line contains N1 space-separated integers for tree 1.\nThe third line contains N2 (number of elements in second tree).\nThe fourth line contains N2 space-separated integers for tree 2.\n\nOutput Format\nPrint YES if trees are identical, otherwise NO.\n\nExample\nInput:\n7\n1 2 3 4 5 -1 -1\n7\n1 2 3 4 5 -1 -1\n\nOutput:\nYES",
            "examples": "Sample Input 1\n7\n1 2 3 4 5 -1 -1\n7\n1 2 3 4 5 -1 -1\n\nSample Output 1\nYES\n\nSample Input 2\n7\n1 2 3 4 5 -1 -1\n5\n1 2 3 -1 5\n\nSample Output 2\nNO",
            "constraints": "1 ≤ N1, N2 ≤ 1000\n1 ≤ nodeValue ≤ 10^6 or -1 for NULL",
            "hints": 2,
            "timeLimit": 5,
            "memoryLimit": 256,
            "difficulty": 2,
            "subdomainId": 2023,
            "streamId": null,
            "testCases": [
                {
                    "input": "7\n1 2 3 4 5 -1 -1\n7\n1 2 3 4 5 -1 -1",
                    "expectedOutput": "YES",
                    "problemTitle": "Check if Two Trees are Identical"
                },
                {
                    "input": "7\n1 2 3 4 5 -1 -1\n5\n1 2 3 -1 5",
                    "expectedOutput": "NO",
                    "problemTitle": "Check if Two Trees are Identical"
                },
                {
                    "input": "1\n10\n1\n10",
                    "expectedOutput": "YES",
                    "problemTitle": "Check if Two Trees are Identical"
                },
                {
                    "input": "3\n1 2 3\n3\n1 3 2",
                    "expectedOutput": "NO",
                    "problemTitle": "Check if Two Trees are Identical"
                },
                {
                    "input": "5\n1 2 -1 3 -1\n5\n1 2 -1 3 -1",
                    "expectedOutput": "YES",
                    "problemTitle": "Check if Two Trees are Identical"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, arr):\n        # TODO: Build tree\n        pass\n\n    def areIdentical(self, root1, root2):\n        # TODO: Check if trees are identical\n        pass\n\ndef solve():\n    n1 = int(input())\n    arr1 = list(map(int, input().split()))\n    n2 = int(input())\n    arr2 = list(map(int, input().split()))\n    sol = Solution()\n    root1 = sol.buildTree(arr1)\n    root2 = sol.buildTree(arr2)\n    result = sol.areIdentical(root1, root2)\n    print(\"YES\" if result else \"NO\")\n\nif __name__ == \"__main__\":\n    solve()",
                    "problemTitle": "Check if Two Trees are Identical"
                },
                {
                    "language": 2,
                    "code": "import java.util.*;\nclass Node {\n    int data;\n    Node left, right;\n    Node(int d) { data = d; }\n}\nclass Solution {\n    Node buildTree(int[] arr) {\n        // TODO: Build tree\n        return null;\n    }\n    boolean areIdentical(Node root1, Node root2) {\n        // TODO: Check identical\n        return false;\n    }\n}\npublic class SolutionMain {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n1 = Integer.parseInt(br.readLine());\n        int[] arr1 = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int n2 = Integer.parseInt(br.readLine());\n        int[] arr2 = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Solution sol = new Solution();\n        Node root1 = sol.buildTree(arr1);\n        Node root2 = sol.buildTree(arr2);\n        System.out.print(sol.areIdentical(root1, root2) ? \"YES\" : \"NO\");\n    }\n}",
                    "problemTitle": "Check if Two Trees are Identical"
                },
                {
                    "language": 3,
                    "code": "class Node {\n  constructor(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n  }\n}\nclass Solution {\n  buildTree(arr) {\n    // TODO: Build tree\n    return null;\n  }\n  areIdentical(root1, root2) {\n    // TODO: Check identical\n    return false;\n  }\n}\nfunction solve(input) {\n  const lines = input.trim().split(\"\\n\");\n  const n1 = parseInt(lines[0]);\n  const arr1 = lines[1].split(\" \").map(Number);\n  const n2 = parseInt(lines[2]);\n  const arr2 = lines[3].split(\" \").map(Number);\n  const sol = new Solution();\n  const root1 = sol.buildTree(arr1);\n  const root2 = sol.buildTree(arr2);\n  console.log(sol.areIdentical(root1, root2) ? \"YES\" : \"NO\");\n}\nconst fs = require(\"fs\");\nsolve(fs.readFileSync(0, \"utf-8\"));",
                    "problemTitle": "Check if Two Trees are Identical"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    Node(int d) { data = d; left = right = NULL; }\n};\nclass Solution {\npublic:\n    Node* buildTree(vector<int>& arr) {\n        // TODO: Build tree\n        return NULL;\n    }\n    bool areIdentical(Node* root1, Node* root2) {\n        // TODO: Check identical\n        return false;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n1, n2;\n    cin >> n1;\n    vector<int> arr1(n1);\n    for (int i = 0; i < n1; i++) cin >> arr1[i];\n    cin >> n2;\n    vector<int> arr2(n2);\n    for (int i = 0; i < n2; i++) cin >> arr2[i];\n    Solution sol;\n    Node* root1 = sol.buildTree(arr1);\n    Node* root2 = sol.buildTree(arr2);\n    cout << (sol.areIdentical(root1, root2) ? \"YES\" : \"NO\");\n}",
                    "problemTitle": "Check if Two Trees are Identical"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* buildTree(int arr[], int n) {\n    // TODO: Build tree\n    return NULL;\n}\n\nbool areIdentical(Node* root1, Node* root2) {\n    // TODO: Check identical\n    return false;\n}\n\nint main() {\n    int n1, n2;\n    scanf(\"%d\", &n1);\n    int arr1[n1];\n    for (int i = 0; i < n1; i++) scanf(\"%d\", &arr1[i]);\n    scanf(\"%d\", &n2);\n    int arr2[n2];\n    for (int i = 0; i < n2; i++) scanf(\"%d\", &arr2[i]);\n    Node* root1 = buildTree(arr1, n1);\n    Node* root2 = buildTree(arr2, n2);\n    printf(\"%s\", areIdentical(root1, root2) ? \"YES\" : \"NO\");\n    return 0;\n}",
                    "problemTitle": "Check if Two Trees are Identical"
                }
            ],
            "hintsList": [
                "Base case: If both nodes are NULL, return true. If one is NULL and other isn't, return false.",
                "Recursive case: Check if data matches AND left subtrees are identical AND right subtrees are identical."
            ]
        },
        {
            "id": null,
            "title": "Mirror a Binary Tree",
            "description": "Problem Statement\n\nGiven a binary tree, convert it to its mirror image.\n\nMirror of a binary tree is obtained by swapping left and right children of all nodes.\n\nYou are given the tree in level-order array format where -1 represents NULL.\n\nInput Format\nThe first line contains N (number of elements).\nThe second line contains N space-separated integers where -1 means NULL.\n\nOutput Format\nPrint the inorder traversal of the mirrored tree, space-separated.\n\nExample\nInput:\n7\n1 2 3 4 5 -1 -1\n\nOutput:\n3 1 5 2 4\n\nExplanation:\nOriginal:     Mirror:\n    1            1\n   / \\          / \\\n  2   3        3   2\n / \\              / \\\n4   5            5   4\n\nInorder of mirror: 3 1 5 2 4",
            "examples": "Sample Input\n7\n1 2 3 4 5 -1 -1\n\nSample Output\n3 1 5 2 4",
            "constraints": "1 ≤ N ≤ 1000\n1 ≤ nodeValue ≤ 10^6 or -1 for NULL",
            "hints": 2,
            "timeLimit": 5,
            "memoryLimit": 256,
            "difficulty": 2,
            "subdomainId": 2023,
            "streamId": null,
            "testCases": [
                {
                    "input": "7\n1 2 3 4 5 -1 -1",
                    "expectedOutput": "3 1 5 2 4",
                    "problemTitle": "Mirror a Binary Tree"
                },
                {
                    "input": "1\n10",
                    "expectedOutput": "10",
                    "problemTitle": "Mirror a Binary Tree"
                },
                {
                    "input": "3\n1 2 3",
                    "expectedOutput": "3 1 2",
                    "problemTitle": "Mirror a Binary Tree"
                },
                {
                    "input": "5\n1 2 -1 3 -1",
                    "expectedOutput": "1 2 3",
                    "problemTitle": "Mirror a Binary Tree"
                },
                {
                    "input": "5\n1 -1 3 -1 4",
                    "expectedOutput": "4 3 1",
                    "problemTitle": "Mirror a Binary Tree"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, arr):\n        # TODO: Build tree\n        pass\n\n    def mirror(self, root):\n        # TODO: Mirror the tree (swap left and right)\n        pass\n\n    def inorderTraversal(self, root):\n        # TODO: Inorder traversal\n        pass\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sol = Solution()\n    root = sol.buildTree(arr)\n    if root is None:\n        print(\"Tree is Empty\")\n        return\n    sol.mirror(root)\n    result = sol.inorderTraversal(root)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
                    "problemTitle": "Mirror a Binary Tree"
                },
                {
                    "language": 2,
                    "code": "import java.util.*;\nclass Node {\n    int data;\n    Node left, right;\n    Node(int d) { data = d; }\n}\nclass Solution {\n    Node buildTree(int[] arr) {\n        // TODO: Build tree\n        return null;\n    }\n    void mirror(Node root) {\n        // TODO: Mirror tree\n    }\n    ArrayList<Integer> inorderTraversal(Node root) {\n        // TODO: Inorder\n        return new ArrayList<>();\n    }\n}\npublic class SolutionMain {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Solution sol = new Solution();\n        Node root = sol.buildTree(arr);\n        if (root == null) {\n            System.out.println(\"Tree is Empty\");\n            return;\n        }\n        sol.mirror(root);\n        ArrayList<Integer> res = sol.inorderTraversal(root);\n        System.out.println(res.toString().replaceAll(\"[\\\\[\\\\],]\", \"\"));\n    }\n}",
                    "problemTitle": "Mirror a Binary Tree"
                },
                {
                    "language": 3,
                    "code": "class Node {\n  constructor(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n  }\n}\nclass Solution {\n  buildTree(arr) {\n    // TODO: Build tree\n    return null;\n  }\n  mirror(root) {\n    // TODO: Mirror tree\n  }\n  inorderTraversal(root) {\n    // TODO: Inorder\n    return [];\n  }\n}\nfunction solve(input) {\n  const lines = input.trim().split(\"\\n\");\n  const n = parseInt(lines[0]);\n  const arr = lines[1].split(\" \").map(Number);\n  const sol = new Solution();\n  const root = sol.buildTree(arr);\n  if (!root) {\n    console.log(\"Tree is Empty\");\n    return;\n  }\n  sol.mirror(root);\n  const res = sol.inorderTraversal(root);\n  console.log(res.join(\" \"));\n}\nconst fs = require(\"fs\");\nsolve(fs.readFileSync(0, \"utf-8\"));",
                    "problemTitle": "Mirror a Binary Tree"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    Node(int d) { data = d; left = right = NULL; }\n};\nclass Solution {\npublic:\n    Node* buildTree(vector<int>& arr) {\n        // TODO: Build tree\n        return NULL;\n    }\n    void mirror(Node* root) {\n        // TODO: Mirror tree\n    }\n    vector<int> inorderTraversal(Node* root) {\n        // TODO: Inorder\n        return {};\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    Solution sol;\n    Node* root = sol.buildTree(arr);\n    if (!root) {\n        cout << \"Tree is Empty\";\n        return 0;\n    }\n    sol.mirror(root);\n    vector<int> res = sol.inorderTraversal(root);\n    for (int i = 0; i < res.size(); i++) {\n        cout << res[i];\n        if (i < res.size() - 1) cout << \" \";\n    }\n}",
                    "problemTitle": "Mirror a Binary Tree"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* buildTree(int arr[], int n) {\n    // TODO: Build tree\n    return NULL;\n}\n\nvoid mirror(Node* root) {\n    // TODO: Mirror tree\n}\n\nvoid inorderTraversal(Node* root) {\n    // TODO: Inorder\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int arr[n];\n    for (int i = 0; i < n; i++) scanf(\"%d\", &arr[i]);\n    Node* root = buildTree(arr, n);\n    if (!root) {\n        printf(\"Tree is Empty\");\n        return 0;\n    }\n    mirror(root);\n    inorderTraversal(root);\n    return 0;\n}",
                    "problemTitle": "Mirror a Binary Tree"
                }
            ],
            "hintsList": [
                "For each node, swap its left and right children. Do this recursively for all nodes.",
                "Base case: if node is NULL, return. Recursive case: swap left and right, then recursively mirror both subtrees."
            ]
        },
        {
            "id": null,
            "title": "Find Maximum Element in Binary Tree",
            "description": "Problem Statement\n\nGiven a binary tree, find the maximum value among all nodes.\n\nYou are given the tree in level-order array format where -1 represents NULL.\n\nInput Format\nThe first line contains N (number of elements).\nThe second line contains N space-separated integers where -1 means NULL.\n\nOutput Format\nPrint the maximum value in the tree. If tree is empty, print \"Tree is Empty\".\n\nExample\nInput:\n7\n1 2 3 4 5 -1 -1\n\nOutput:\n5\n\nExplanation:\nNodes: 1, 2, 3, 4, 5\nMaximum = 5",
            "examples": "Sample Input\n7\n1 2 3 4 5 -1 -1\n\nSample Output\n5",
            "constraints": "1 ≤ N ≤ 1000\n-10^9 ≤ nodeValue ≤ 10^9 or -1 for NULL",
            "hints": 2,
            "timeLimit": 5,
            "memoryLimit": 256,
            "difficulty": 1,
            "subdomainId": 2023,
            "streamId": null,
            "testCases": [
                {
                    "input": "7\n1 2 3 4 5 -1 -1",
                    "expectedOutput": "5",
                    "problemTitle": "Find Maximum Element in Binary Tree"
                },
                {
                    "input": "1\n10",
                    "expectedOutput": "10",
                    "problemTitle": "Find Maximum Element in Binary Tree"
                },
                {
                    "input": "5\n100 50 75 25 60",
                    "expectedOutput": "100",
                    "problemTitle": "Find Maximum Element in Binary Tree"
                },
                {
                    "input": "5\n1 -1 3 -1 100",
                    "expectedOutput": "100",
                    "problemTitle": "Find Maximum Element in Binary Tree"
                },
                {
                    "input": "7\n-5 -10 -3 -20 -1 -1 -1",
                    "expectedOutput": "-1",
                    "problemTitle": "Find Maximum Element in Binary Tree"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, arr):\n        # TODO: Build tree\n        pass\n\n    def findMax(self, root):\n        # TODO: Find maximum value\n        pass\n\ndef solve():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    sol = Solution()\n    root = sol.buildTree(arr)\n    if root is None:\n        print(\"Tree is Empty\")\n        return\n    result = sol.findMax(root)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
                    "problemTitle": "Find Maximum Element in Binary Tree"
                },
                {
                    "language": 2,
                    "code": "import java.util.*;\nclass Node {\n    int data;\n    Node left, right;\n    Node(int d) { data = d; }\n}\nclass Solution {\n    Node buildTree(int[] arr) {\n        // TODO: Build tree\n        return null;\n    }\n    int findMax(Node root) {\n        // TODO: Find max\n        return Integer.MIN_VALUE;\n    }\n}\npublic class SolutionMain {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] arr = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Solution sol = new Solution();\n        Node root = sol.buildTree(arr);\n        if (root == null) {\n            System.out.println(\"Tree is Empty\");\n            return;\n        }\n        System.out.println(sol.findMax(root));\n    }\n}",
                    "problemTitle": "Find Maximum Element in Binary Tree"
                },
                {
                    "language": 3,
                    "code": "class Node {\n  constructor(data) {\n    this.data = data;\n    this.left = null;\n    this.right = null;\n  }\n}\nclass Solution {\n  buildTree(arr) {\n    // TODO: Build tree\n    return null;\n  }\n  findMax(root) {\n    // TODO: Find max\n    return -Infinity;\n  }\n}\nfunction solve(input) {\n  const lines = input.trim().split(\"\\n\");\n  const n = parseInt(lines[0]);\n  const arr = lines[1].split(\" \").map(Number);\n  const sol = new Solution();\n  const root = sol.buildTree(arr);\n  if (!root) {\n    console.log(\"Tree is Empty\");\n    return;\n  }\n  console.log(sol.findMax(root));\n}\nconst fs = require(\"fs\");\nsolve(fs.readFileSync(0, \"utf-8\"));",
                    "problemTitle": "Find Maximum Element in Binary Tree"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    Node(int d) { data = d; left = right = NULL; }\n};\nclass Solution {\npublic:\n    Node* buildTree(vector<int>& arr) {\n        // TODO: Build tree\n        return NULL;\n    }\n    int findMax(Node* root) {\n        // TODO: Find max\n        return INT_MIN;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; i++) cin >> arr[i];\n    Solution sol;\n    Node* root = sol.buildTree(arr);\n    if (!root) {\n        cout << \"Tree is Empty\";\n        return 0;\n    }\n    cout << sol.findMax(root);\n}",
                    "problemTitle": "Find Maximum Element in Binary Tree"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* buildTree(int arr[], int n) {\n    // TODO: Build tree\n    return NULL;\n}\n\nint findMax(Node* root) {\n    // TODO: Find max\n    return INT_MIN;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int arr[n];\n    for (int i = 0; i < n; i++) scanf(\"%d\", &arr[i]);\n    Node* root = buildTree(arr, n);\n    if (!root) {\n        printf(\"Tree is Empty\");\n        return 0;\n    }\n    printf(\"%d\", findMax(root));\n    return 0;\n}",
                    "problemTitle": "Find Maximum Element in Binary Tree"
                }
            ],
            "hintsList": [
                "Use recursion: max = max(root.data, max of left subtree, max of right subtree).",
                "Base case: if node is NULL, return negative infinity. Otherwise return max of current, left max, and right max."
            ]
        }
    ]
}

