{
    "problems": [
        {
            "id": null,
            "title": "Unique Paths III (Bit Manipulation)",
            "description": "Problem Statement\n\nYou are given an m x n integer array grid where grid[i][j] could be:\n1 representing the starting square. There is exactly one starting square.\n2 representing the ending square. There is exactly one ending square.\n0 representing empty squares we can walk over.\n-1 representing obstacles that we cannot walk over.\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.\n",
            "examples": "Sample Input\n1 0 0 0\n0 0 0 0\n0 0 2 -1\n\nSample Output\n2\n\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\nSample Input\n1 0 0 0\n0 0 0 0\n0 0 0 2\n\nSample Output\n4\n\nExplanation: We have four different paths.\n\nSample Input\n0 1\n2 0\n\nSample Output\n0\n\nExplanation: There is no path that walks over every empty square exactly once.",
            "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 20\n1 <= m * n <= 20\n-1 <= grid[i][j] <= 2\nThere is exactly one starting cell and one ending cell.",
            "hints": 2,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 6033,
            "difficulty": 3,
            "testCases": [
                {
                    "input": "0 1\n2 0",
                    "expectedOutput": "0"
                },
                {
                    "input": "0 0 0\n1 0 0\n0 2 -1",
                    "expectedOutput": "0"
                },
                {
                    "input": "1 0 2\n-1 0 0\n0 0 0",
                    "expectedOutput": "0"
                },
                {
                    "input": "0 0 1\n0 0 0\n2 0 0",
                    "expectedOutput": "2"
                },
                {
                    "input": "1 0 0\n0 0 0\n0 0 2",
                    "expectedOutput": "2"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def uniquePathsIII(self, grid):\n        # TODO: Return number of paths walking over every non-obstacle square exactly once\n        pass\n\nif __name__ == '__main__':\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    grid = []\n    for line in lines:\n        if line.strip():\n            grid.append(list(map(int, line.strip().split())))\n    sol = Solution()\n    print(sol.uniquePathsIII(grid))"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public int uniquePathsIII(int[][] grid) {\n        // TODO: Return number of paths walking over every non-obstacle square exactly once\n        return 0;\n    }\n    \n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        List<int[]> gridList = new ArrayList<>();\n        String line;\n        while ((line = br.readLine()) != null && !line.trim().isEmpty()) {\n            String[] parts = line.trim().split(\" \");\n            int[] row = new int[parts.length];\n            for (int i = 0; i < parts.length; i++) {\n                row[i] = Integer.parseInt(parts[i]);\n            }\n            gridList.add(row);\n        }\n        int[][] grid = gridList.toArray(new int[gridList.size()][]);\n        Solution sol = new Solution();\n        System.out.println(sol.uniquePathsIII(grid));\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    uniquePathsIII(grid) {\n        // TODO: Return number of paths walking over every non-obstacle square exactly once\n        return 0;\n    }\n}\n\nfunction solve(input) {\n    const lines = input.trim().split('\\n');\n    const grid = [];\n    for (const line of lines) {\n        if (line.trim()) {\n            grid.push(line.trim().split(/\\s+/).map(Number));\n        }\n    }\n    const sol = new Solution();\n    console.log(sol.uniquePathsIII(grid));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        // TODO: Return number of paths walking over every non-obstacle square exactly once\n        return 0;\n    }\n};\n\nint main() {\n    vector<vector<int>> grid;\n    string line;\n    while (getline(cin, line) && !line.empty()) {\n        istringstream iss(line);\n        vector<int> row;\n        int num;\n        while (iss >> num) {\n            row.push_back(num);\n        }\n        if (!row.empty()) {\n            grid.push_back(row);\n        }\n    }\n    Solution sol;\n    cout << sol.uniquePathsIII(grid) << endl;\n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid uniquePathsIII(int** grid, int gridSize, int* gridColSize) {\n    // TODO: Print number of paths walking over every non-obstacle square exactly once\n}\n\nint main() {\n    int grid[20][20];\n    int gridSize = 0;\n    int gridColSize[20];\n    char line[1000];\n    while (fgets(line, sizeof(line), stdin) && line[0] != '\\n') {\n        int row[20];\n        int colSize = 0;\n        char* token = strtok(line, \" \\n\");\n        while (token != NULL) {\n            row[colSize++] = atoi(token);\n            token = strtok(NULL, \" \\n\");\n        }\n        if (colSize > 0) {\n            for (int i = 0; i < colSize; i++) {\n                grid[gridSize][i] = row[i];\n            }\n            gridColSize[gridSize] = colSize;\n            gridSize++;\n        }\n    }\n    int* gridPtrs[20];\n    for (int i = 0; i < gridSize; i++) {\n        gridPtrs[i] = grid[i];\n    }\n    uniquePathsIII(gridPtrs, gridSize, gridColSize);\n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Use DFS/backtracking to explore all paths from start to end.",
                "Use bit manipulation to track which cells have been visited."
            ]
        }
    ]
}

