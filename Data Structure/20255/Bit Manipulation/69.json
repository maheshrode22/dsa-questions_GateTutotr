{
    "problems": [
        {
            "id": null,
            "title": "Can Make Palindrome from Substring (Bit Manipulation)",
            "description": "Problem Statement\n\nYou are given a string s and array queries where queries[i] = [lefti, righti, ki]. We may rearrange the substring s[lefti...righti] for each query and then choose up to ki of them to replace with any lowercase English letter.\nIf the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.\nReturn a boolean array answer where answer[i] is the result of the ith query queries[i].\nNote that each letter is counted individually for replacement, so if, for example s[lefti...righti] = \"aaa\", and ki = 2, we can only replace two of the letters. Also, note that no query modifies the initial string s.\n",
            "examples": "Sample Input\nabcda\n3 3 0\n1 2 0\n0 3 1\n0 3 2\n0 4 1\n\nSample Output\nTrue False False True True\n\nExplanation:\nqueries[0]: substring = \"d\", is palindrome.\nqueries[1]: substring = \"bc\", is not palindrome.\nqueries[2]: substring = \"abcd\", is not palindrome after replacing only 1 character.\nqueries[3]: substring = \"abcd\", could be changed to \"abba\" which is palindrome.\nqueries[4]: substring = \"abcda\", could be changed to \"abcba\" which is palindrome.\n\nSample Input\nlyb\n0 1 0\n2 2 1\n\nSample Output\nFalse True",
            "constraints": "1 <= s.length, queries.length <= 10^5\n0 <= lefti <= righti < s.length\n0 <= ki <= s.length\ns consists of lowercase English letters.",
            "hints": 2,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 6033,
            "difficulty": 2,
            "testCases": [
                {
                    "input": "abcd\n0 2 1\n1 3 1",
                    "expectedOutput": "True True"
                },
                {
                    "input": "zaz\n0 2 1\n0 1 0\n1 2 0",
                    "expectedOutput": "True False False"
                },
                {
                    "input": "abcda\n3 3 0\n1 2 0\n0 3 1\n0 3 2\n0 4 1",
                    "expectedOutput": "True False False True True"
                },
                {
                    "input": "aaaa\n0 3 0\n1 2 0",
                    "expectedOutput": "True True"
                },
                {
                    "input": "aabbc\n0 4 2\n1 3 1",
                    "expectedOutput": "True True"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def canMakePaliQueries(self, s, queries):\n        # TODO: Return list of booleans for each query\n        pass\n\nif __name__ == '__main__':\n    import sys\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    s = lines[0]\n    queries = []\n    for i in range(1, len(lines)):\n        parts = list(map(int, lines[i].split()))\n        queries.append(parts)\n    sol = Solution()\n    result = sol.canMakePaliQueries(s, queries)\n    print(' '.join('True' if x else 'False' for x in result))"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\n        // TODO: Return list of booleans for each query\n        return new ArrayList<>();\n    }\n    \n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s = br.readLine().trim();\n        List<int[]> queriesList = new ArrayList<>();\n        String line;\n        while ((line = br.readLine()) != null && !line.trim().isEmpty()) {\n            String[] parts = line.trim().split(\" \");\n            queriesList.add(new int[]{Integer.parseInt(parts[0]), Integer.parseInt(parts[1]), Integer.parseInt(parts[2])});\n        }\n        int[][] queries = queriesList.toArray(new int[queriesList.size()][]);\n        Solution sol = new Solution();\n        List<Boolean> result = sol.canMakePaliQueries(s, queries);\n        for (int i = 0; i < result.size(); i++) {\n            System.out.print(result.get(i) ? \"True\" : \"False\");\n            if (i < result.size() - 1) System.out.print(\" \");\n        }\n        System.out.println();\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    canMakePaliQueries(s, queries) {\n        // TODO: Return array of booleans for each query\n        return [];\n    }\n}\n\nfunction solve(input) {\n    const lines = input.trim().split('\\n');\n    const s = lines[0].trim();\n    const queries = [];\n    for (let i = 1; i < lines.length; i++) {\n        queries.push(lines[i].trim().split(/\\s+/).map(Number));\n    }\n    const sol = new Solution();\n    const result = sol.canMakePaliQueries(s, queries);\n    console.log(result.map(x => x ? 'True' : 'False').join(' '));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\n        // TODO: Return vector of booleans for each query\n        return {};\n    }\n};\n\nint main() {\n    string s;\n    getline(cin, s);\n    vector<vector<int>> queries;\n    string line;\n    while (getline(cin, line) && !line.empty()) {\n        istringstream iss(line);\n        vector<int> query;\n        int num;\n        while (iss >> num) {\n            query.push_back(num);\n        }\n        queries.push_back(query);\n    }\n    Solution sol;\n    vector<bool> result = sol.canMakePaliQueries(s, queries);\n    for (int i = 0; i < result.size(); i++) {\n        cout << (result[i] ? \"True\" : \"False\");\n        if (i < result.size() - 1) cout << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\nvoid canMakePaliQueries(char* s, int** queries, int queriesSize, int* queriesColSize) {\n    // TODO: Print space-separated booleans (True/False) for each query\n}\n\nint main() {\n    char s[100005];\n    fgets(s, sizeof(s), stdin);\n    s[strcspn(s, \"\\n\")] = 0;\n    // Simplified - would need more complex parsing for queries\n    printf(\"TODO: Implement input parsing\\n\");\n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Count the frequency of each character in the substring.",
                "A string can form a palindrome if at most one character has odd frequency (after rearranging and replacing)."
            ]
        }
    ]
}

