{
    "problems": [
        {
            "id": null,
            "title": "Shortest Path Visiting All Nodes (Bit Manipulation)",
            "description": "Problem Statement\n\nYou have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge.\nReturn the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n",
            "examples": "Sample Input\n1 2 3\n0\n0\n0\n\nSample Output\n4\n\nExplanation: One possible path is [1,0,2,0,3]\n\nSample Input\n1\n0 2 4\n1 3 4\n2\n1 2\n\nSample Output\n4\n\nExplanation: One possible path is [0,1,4,2,3]",
            "constraints": "n == graph.length\n1 <= n <= 12\n0 <= graph[i].length < n\ngraph[i] does not contain i.\nIf graph[a] contains b, then graph[b] contains a.\nThe input graph is always connected.",
            "hints": 2,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 6033,
            "difficulty": 3,
            "testCases": [
                {
                    "input": "1 2 3\n0\n0\n0",
                    "expectedOutput": "4"
                },
                {
                    "input": "1\n0 2 4\n1 3 4\n2\n1 2",
                    "expectedOutput": "4"
                },
                {
                    "input": "1 2\n0 2 3\n0 1\n1",
                    "expectedOutput": "3"
                },
                {
                    "input": "1 2 3 4 5\n0 2 3 4 5\n0 1 3 4 5\n0 1 2 4 5\n0 1 2 3 5\n0 1 2 3 4",
                    "expectedOutput": "5"
                },
                {
                    "input": "1 2\n0\n0",
                    "expectedOutput": "2"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def shortestPathLength(self, graph):\n        # TODO: Return length of shortest path visiting all nodes\n        pass\n\nif __name__ == '__main__':\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    graph = []\n    for line in lines:\n        if line.strip():\n            graph.append(list(map(int, line.strip().split())))\n    sol = Solution()\n    print(sol.shortestPathLength(graph))"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public int shortestPathLength(int[][] graph) {\n        // TODO: Return length of shortest path visiting all nodes\n        return 0;\n    }\n    \n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        List<List<Integer>> graphList = new ArrayList<>();\n        String line;\n        while ((line = br.readLine()) != null && !line.trim().isEmpty()) {\n            String[] parts = line.trim().split(\" \");\n            List<Integer> neighbors = new ArrayList<>();\n            for (String part : parts) {\n                neighbors.add(Integer.parseInt(part));\n            }\n            graphList.add(neighbors);\n        }\n        int[][] graph = new int[graphList.size()][];\n        for (int i = 0; i < graphList.size(); i++) {\n            graph[i] = graphList.get(i).stream().mapToInt(Integer::intValue).toArray();\n        }\n        Solution sol = new Solution();\n        System.out.println(sol.shortestPathLength(graph));\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    shortestPathLength(graph) {\n        // TODO: Return length of shortest path visiting all nodes\n        return 0;\n    }\n}\n\nfunction solve(input) {\n    const lines = input.trim().split('\\n');\n    const graph = [];\n    for (const line of lines) {\n        if (line.trim()) {\n            graph.push(line.trim().split(/\\s+/).map(Number));\n        }\n    }\n    const sol = new Solution();\n    console.log(sol.shortestPathLength(graph));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int shortestPathLength(vector<vector<int>>& graph) {\n        // TODO: Return length of shortest path visiting all nodes\n        return 0;\n    }\n};\n\nint main() {\n    vector<vector<int>> graph;\n    string line;\n    while (getline(cin, line) && !line.empty()) {\n        istringstream iss(line);\n        vector<int> neighbors;\n        int num;\n        while (iss >> num) {\n            neighbors.push_back(num);\n        }\n        if (!neighbors.empty()) {\n            graph.push_back(neighbors);\n        }\n    }\n    Solution sol;\n    cout << sol.shortestPathLength(graph) << endl;\n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid shortestPathLength(int** graph, int graphSize, int* graphColSize) {\n    // TODO: Print length of shortest path visiting all nodes\n}\n\nint main() {\n    int graph[12][12];\n    int graphSize = 0;\n    int graphColSize[12];\n    char line[1000];\n    while (fgets(line, sizeof(line), stdin) && line[0] != '\\n') {\n        int neighbors[12];\n        int colSize = 0;\n        char* token = strtok(line, \" \\n\");\n        while (token != NULL) {\n            neighbors[colSize++] = atoi(token);\n            token = strtok(NULL, \" \\n\");\n        }\n        if (colSize > 0) {\n            for (int i = 0; i < colSize; i++) {\n                graph[graphSize][i] = neighbors[i];\n            }\n            graphColSize[graphSize] = colSize;\n            graphSize++;\n        }\n    }\n    int* graphPtrs[12];\n    for (int i = 0; i < graphSize; i++) {\n        graphPtrs[i] = graph[i];\n    }\n    shortestPathLength(graphPtrs, graphSize, graphColSize);\n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Use BFS with state (current_node, visited_nodes_bitmask).",
                "Track visited nodes using bit manipulation: mask = 1 << node."
            ]
        }
    ]
}

