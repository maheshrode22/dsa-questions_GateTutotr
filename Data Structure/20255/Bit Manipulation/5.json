{
    "problems": [
        {
            "id": null,
            "title": "Subsets II (Bit Manipulation)",
            "description": "Problem Statement\n\nGiven an integer array nums that may contain duplicates, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n",
            "examples": "Sample Input\n1 2 2\n\nSample Output\n[] [1] [2] [1,2] [2,2] [1,2,2]\n\nExplanation: All possible subsets without duplicates.\n\nSample Input\n0\n\nSample Output\n[] [0]\n\nExplanation: All possible subsets of [0].",
            "constraints": "1 <= nums.length <= 10\n-10 <= nums[i] <= 10",
            "hints": 2,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 6033,
            "difficulty": 2,
            "testCases": [
                {
                    "input": "1 2 2",
                    "expectedOutput": "[] [1] [2] [1,2] [2,2] [1,2,2]"
                },
                {
                    "input": "0",
                    "expectedOutput": "[] [0]"
                },
                {
                    "input": "-1 1 -1 1",
                    "expectedOutput": "[] [-1] [1] [-1,-1] [-1,1] [1,1] [-1,-1,1] [-1,1,1] [-1,-1,1,1]"
                },
                {
                    "input": "1 2 2 3",
                    "expectedOutput": "[] [1] [2] [3] [1,2] [1,3] [2,2] [2,3] [1,2,2] [1,2,3] [2,2,3] [1,2,2,3]"
                },
                {
                    "input": "2 1 2",
                    "expectedOutput": "[] [1] [2] [1,2] [2,2] [1,2,2]"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def subsetsWithDup(self, nums):\n        # TODO: Return all possible subsets without duplicates\n        pass\n\nif __name__ == '__main__':\n    import sys\n    nums = list(map(int, sys.stdin.read().strip().split()))\n    sol = Solution()\n    result = sol.subsetsWithDup(nums)\n    # Format output: [] [1] [2] [1,2] ...\n    output = []\n    for subset in result:\n        output.append('[' + ','.join(map(str, subset)) + ']')\n    print(' '.join(output))"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        // TODO: Return all possible subsets without duplicates\n        return new ArrayList<>();\n    }\n    \n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] parts = br.readLine().trim().split(\" \");\n        int[] nums = new int[parts.length];\n        for (int i = 0; i < parts.length; i++) {\n            nums[i] = Integer.parseInt(parts[i]);\n        }\n        Solution sol = new Solution();\n        List<List<Integer>> result = sol.subsetsWithDup(nums);\n        for (int i = 0; i < result.size(); i++) {\n            System.out.print(result.get(i).toString().replace(\" \", \"\") + (i == result.size() - 1 ? \"\" : \" \"));\n        }\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    subsetsWithDup(nums) {\n        // TODO: Return all possible subsets without duplicates\n        return [];\n    }\n}\n\nfunction solve(input) {\n    const nums = input.trim().split(/\\s+/).map(Number);\n    const sol = new Solution();\n    const result = sol.subsetsWithDup(nums);\n    const output = result.map(subset => '[' + subset.join(',') + ']');\n    console.log(output.join(' '));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        // TODO: Return all possible subsets without duplicates\n        return {};\n    }\n};\n\nint main() {\n    string line;\n    getline(cin, line);\n    istringstream iss(line);\n    vector<int> nums;\n    int num;\n    while (iss >> num) {\n        nums.push_back(num);\n    }\n    Solution sol;\n    vector<vector<int>> result = sol.subsetsWithDup(nums);\n    for (int i = 0; i < result.size(); i++) {\n        cout << \"[\";\n        for (int j = 0; j < result[i].size(); j++) {\n            cout << result[i][j] << (j == result[i].size() - 1 ? \"\" : \",\");\n        }\n        cout << \"]\" << (i == result.size() - 1 ? \"\" : \" \");\n    }\n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid subsetsWithDup(int* nums, int numsSize) {\n    // TODO: Print all possible subsets without duplicates\n}\n\nint main() {\n    int nums[15];\n    int numsSize = 0;\n    char line[200];\n    fgets(line, sizeof(line), stdin);\n    char* token = strtok(line, \" \\n\");\n    while (token != NULL) {\n        nums[numsSize++] = atoi(token);\n        token = strtok(NULL, \" \\n\");\n    }\n    subsetsWithDup(nums, numsSize);\n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Sort the array first to handle duplicates easily.",
                "Use bit manipulation or backtracking, but skip duplicate subsets."
            ]
        }
    ]
}

