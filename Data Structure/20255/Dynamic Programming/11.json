{
    "problems": [
        {
            "id": null,
            "title": "Edit Distance (Levenshtein Distance)",
            "description": "Problem Statement\n\nGiven two strings word1 and word2, find the minimum number of operations required to convert word1 to word2.\n\nYou can perform three operations:\n1. Insert a character\n2. Delete a character\n3. Replace a character\n\nThis is the classic Edit Distance (Levenshtein Distance) problem.\n\nDP State: dp[i][j] = min operations to convert word1[0..i-1] to word2[0..j-1].\n",
            "examples": "Sample Input\nhorse\nros\n\nSample Output\n3\n\nExplanation:\nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\n3 operations total.",
            "constraints": "0 <= |word1|, |word2| <= 500\nStrings contain only lowercase English letters.",
            "hints": 2,
            "timeLimit": 5,
            "memoryLimit": 256,
            "subdomainId": 2029,
            "difficulty": 3,
            "testCases": [
                {
                    "input": "horse\nros",
                    "expectedOutput": "3"
                },
                {
                    "input": "intention\nexecution",
                    "expectedOutput": "5"
                },
                {
                    "input": "abc\nabc",
                    "expectedOutput": "0"
                },
                {
                    "input": "abc\n",
                    "expectedOutput": "3"
                },
                {
                    "input": "kitten\nsitting",
                    "expectedOutput": "3"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def minDistance(self, word1, word2):\n        # TODO: 2D DP for edit distance\n        # If chars match: dp[i][j] = dp[i-1][j-1]\n        # Else: dp[i][j] = 1 + min(insert, delete, replace)\n        pass\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip().split('\\n')\n    word1 = data[0] if len(data) > 0 else \"\"\n    word2 = data[1] if len(data) > 1 else \"\"\n    sol = Solution()\n    print(sol.minDistance(word1, word2))"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public int minDistance(String word1, String word2) {\n        // TODO: 2D DP for edit distance\n        // If chars match: dp[i][j] = dp[i-1][j-1]\n        // Else: dp[i][j] = 1 + min(insert, delete, replace)\n        return 0;\n    }\n    \n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String word1 = br.readLine();\n        if (word1 == null) word1 = \"\";\n        String word2 = br.readLine();\n        if (word2 == null) word2 = \"\";\n        Solution sol = new Solution();\n        System.out.println(sol.minDistance(word1, word2));\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    minDistance(word1, word2) {\n        // TODO: 2D DP for edit distance\n        // If chars match: dp[i][j] = dp[i-1][j-1]\n        // Else: dp[i][j] = 1 + min(insert, delete, replace)\n        return 0;\n    }\n}\n\nfunction solve(input) {\n    const lines = input.split('\\n');\n    const word1 = lines[0] || \"\";\n    const word2 = lines[1] || \"\";\n    const sol = new Solution();\n    console.log(sol.minDistance(word1, word2));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        // TODO: 2D DP for edit distance\n        // If chars match: dp[i][j] = dp[i-1][j-1]\n        // Else: dp[i][j] = 1 + min(insert, delete, replace)\n        return 0;\n    }\n};\n\nint main() {\n    string word1, word2;\n    getline(cin, word1);\n    getline(cin, word2);\n    Solution sol;\n    cout << sol.minDistance(word1, word2);\n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <string.h>\n\nint min3(int a, int b, int c) {\n    int min = a < b ? a : b;\n    return min < c ? min : c;\n}\n\nint minDistance(char* word1, char* word2) {\n    // TODO: 2D DP for edit distance\n    // If chars match: dp[i][j] = dp[i-1][j-1]\n    // Else: dp[i][j] = 1 + min(insert, delete, replace)\n    return 0;\n}\n\nint main() {\n    char word1[505], word2[505];\n    if (fgets(word1, 505, stdin)) word1[strcspn(word1, \"\\n\")] = 0;\n    else word1[0] = 0;\n    if (fgets(word2, 505, stdin)) word2[strcspn(word2, \"\\n\")] = 0;\n    else word2[0] = 0;\n    printf(\"%d\", minDistance(word1, word2));\n    return 0;\n}"
                }
            ],
            "hintsList": [
                "dp[i][j] represents min ops to convert first i chars of word1 to first j chars of word2. Base: dp[i][0]=i, dp[0][j]=j.",
                "If word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1]. Else: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])."
            ]
        }
    ]
}