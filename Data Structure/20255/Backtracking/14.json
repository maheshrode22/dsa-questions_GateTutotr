{
    "problems": [
        {
            "id": null,
            "title": "M-Coloring Problem",
            "description": "Problem Statement\n\nGiven an undirected graph and an integer M. Determine if the graph can be colored with at most M colors such that no two adjacent vertices of the graph are colored with the same color.\n\nReturn true if possible, false otherwise.\n",
            "examples": "Sample Input\n4 3\n0 1 1 1\n1 0 1 0\n1 1 0 1\n1 0 1 0\n\nSample Output\ntrue\n\nExplanation:\nGraph with 4 nodes, 3 colors. Adjacency matrix given.",
            "constraints": "1 <= N <= 20\n1 <= M <= N",
            "hints": 2,
            "timeLimit": 5,
            "memoryLimit": 256,
            "subdomainId": 2030,
            "difficulty": 3,
            "testCases": [
                {
                    "input": "4 3\n0 1 1 1\n1 0 1 0\n1 1 0 1\n1 0 1 0",
                    "expectedOutput": "true"
                },
                {
                    "input": "3 2\n0 1 1\n1 0 1\n1 1 0",
                    "expectedOutput": "false"
                },
                {
                    "input": "3 3\n0 1 1\n1 0 1\n1 1 0",
                    "expectedOutput": "true"
                },
                {
                    "input": "2 1\n0 1\n1 0",
                    "expectedOutput": "false"
                },
                {
                    "input": "5 2\n0 1 0 0 1\n1 0 1 0 0\n0 1 0 1 0\n0 0 1 0 1\n1 0 0 1 0",
                    "expectedOutput": "false"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def graphColoring(self, graph, m, n):\n        # TODO: Check if graph can be colored with m colors\n        pass\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip().split('\\n')\n    n, m = map(int, data[0].split())\n    graph = []\n    for i in range(n):\n        graph.append(list(map(int, data[i+1].split())))\n    sol = Solution()\n    print('true' if sol.graphColoring(graph, m, n) else 'false')"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public boolean graphColoring(int[][] graph, int m, int n) {\n        # TODO: Check if graph can be colored with m colors\n        return false;\n    }\n    \n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] parts = br.readLine().trim().split(\" \");\n        int n = Integer.parseInt(parts[0]);\n        int m = Integer.parseInt(parts[1]);\n        int[][] graph = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            String[] row = br.readLine().trim().split(\" \");\n            for (int j = 0; j < n; j++) graph[i][j] = Integer.parseInt(row[j]);\n        }\n        Solution sol = new Solution();\n        System.out.println(sol.graphColoring(graph, m, n) ? \"true\" : \"false\");\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    graphColoring(graph, m, n) {\n        # TODO: Check if graph can be colored with m colors\n        return false;\n    }\n}\n\nfunction solve(input) {\n    const lines = input.trim().split('\\n');\n    const [n, m] = lines[0].split(' ').map(Number);\n    const graph = [];\n    for (let i = 0; i < n; i++) {\n        graph.push(lines[i+1].split(' ').map(Number));\n    }\n    const sol = new Solution();\n    console.log(sol.graphColoring(graph, m, n) ? 'true' : 'false');\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool graphColoring(vector<vector<int>>& graph, int m, int n) {\n        # TODO: Check if graph can be colored with m colors\n        return false;\n    }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> graph(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) cin >> graph[i][j];\n    }\n    Solution sol;\n    cout << (sol.graphColoring(graph, m, n) ? \"true\" : \"false\");\n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\nbool graphColoring(int** graph, int m, int n) {\n    # TODO: Check if graph can be colored with m colors\n    return false;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int** graph = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        graph[i] = (int*)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++) scanf(\"%d\", &graph[i][j]);\n    }\n    printf(\"%s\", graphColoring(graph, m, n) ? \"true\" : \"false\");\n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Assign colors 1 to m to vertex 1. If valid, recurse for vertex 2.",
                "Check validity: adjacent vertices must not have same color."
            ]
        }
    ]
}