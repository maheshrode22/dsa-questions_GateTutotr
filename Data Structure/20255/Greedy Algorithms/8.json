{
    "problems": [
        {
            "id": null,
            "title": "Minimum Platforms Required",
            "description": "Problem Statement\n\nYou are given the arrival and departure times of N trains at a railway station.\nFind the minimum number of platforms required so that no train has to wait.\n\nTwo trains can share a platform only if one departs before the other arrives.\n\nGreedy Approach: Track how many trains are at the station at any point in time.\n",
            "examples": "Sample Input\n6\n900 940 950 1100 1500 1800\n910 1200 1120 1130 1900 2000\n\nSample Output\n3\n\nExplanation:\nArrivals:   [900, 940, 950, 1100, 1500, 1800]\nDepartures: [910, 1200, 1120, 1130, 1900, 2000]\n\nTimeline:\n- 900: Train 1 arrives (platforms: 1)\n- 910: Train 1 departs (platforms: 0)\n- 940: Train 2 arrives (platforms: 1)\n- 950: Train 3 arrives (platforms: 2)\n- 1100: Train 4 arrives (platforms: 3) ‚Üê Maximum!\n- 1120: Train 3 departs (platforms: 2)\n- 1130: Train 4 departs (platforms: 1)\n- 1200: Train 2 departs (platforms: 0)\n... and so on\n\nMinimum platforms needed = 3",
            "constraints": "1 <= N <= 1000\n0 <= arrival[i] < departure[i] <= 2359\nTimes are in HHMM format (e.g., 900 means 9:00 AM)",
            "hints": 2,
            "timeLimit": 5,
            "memoryLimit": 256,
            "subdomainId": 2028,
            "difficulty": 2,
            "testCases": [
                {
                    "input": "6\n900 940 950 1100 1500 1800\n910 1200 1120 1130 1900 2000",
                    "expectedOutput": "3"
                },
                {
                    "input": "3\n100 200 300\n150 250 350",
                    "expectedOutput": "1"
                },
                {
                    "input": "4\n100 100 100 100\n200 200 200 200",
                    "expectedOutput": "4"
                },
                {
                    "input": "5\n900 1000 1100 1200 1300\n930 1030 1130 1230 1330",
                    "expectedOutput": "1"
                },
                {
                    "input": "4\n100 110 120 130\n200 210 220 230",
                    "expectedOutput": "4"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def minPlatforms(self, arrivals, departures):\n        # TODO: Sort both arrays\n        # Use two pointers to simulate events in chronological order\n        # Count overlapping trains\n        pass\n\nif __name__ == '__main__':\n    import sys\n    data = sys.stdin.read().strip().split('\\n')\n    n = int(data[0])\n    arrivals = list(map(int, data[1].split()))\n    departures = list(map(int, data[2].split()))\n    sol = Solution()\n    print(sol.minPlatforms(arrivals, departures))"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public int minPlatforms(int[] arrivals, int[] departures) {\n        // TODO: Sort both arrays\n        // Use two pointers to simulate events in chronological order\n        return 0;\n    }\n    \n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine().trim());\n        String[] arrParts = br.readLine().trim().split(\" \");\n        String[] depParts = br.readLine().trim().split(\" \");\n        int[] arrivals = new int[n];\n        int[] departures = new int[n];\n        for (int i = 0; i < n; i++) {\n            arrivals[i] = Integer.parseInt(arrParts[i]);\n            departures[i] = Integer.parseInt(depParts[i]);\n        }\n        Solution sol = new Solution();\n        System.out.println(sol.minPlatforms(arrivals, departures));\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    minPlatforms(arrivals, departures) {\n        // TODO: Sort both arrays\n        // Use two pointers to simulate events in chronological order\n        return 0;\n    }\n}\n\nfunction solve(input) {\n    const lines = input.trim().split('\\n');\n    const n = parseInt(lines[0]);\n    const arrivals = lines[1].split(' ').map(Number);\n    const departures = lines[2].split(' ').map(Number);\n    const sol = new Solution();\n    console.log(sol.minPlatforms(arrivals, departures));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minPlatforms(vector<int>& arrivals, vector<int>& departures) {\n        // TODO: Sort both arrays\n        // Use two pointers to simulate events in chronological order\n        return 0;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arrivals(n), departures(n);\n    for (int i = 0; i < n; i++) cin >> arrivals[i];\n    for (int i = 0; i < n; i++) cin >> departures[i];\n    Solution sol;\n    cout << sol.minPlatforms(arrivals, departures);\n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void* a, const void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint minPlatforms(int arrivals[], int departures[], int n) {\n    // TODO: Sort both arrays\n    // Use two pointers to simulate events in chronological order\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    int arrivals[n], departures[n];\n    for (int i = 0; i < n; i++) scanf(\"%d\", &arrivals[i]);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &departures[i]);\n    printf(\"%d\", minPlatforms(arrivals, departures, n));\n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Sort arrival and departure times separately. Then use two pointers to process events in time order.",
                "If next event is arrival: platforms++. If departure: platforms--. Track the maximum platforms needed."
            ]
        }
    ]
}