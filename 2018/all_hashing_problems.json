{
    "problems": [
        {
            "id": null,
            "title": "Linear Probing Simulation",
            "description": "Problem Statement\nImplement a hash table of size M using Linear Probing for collision resolution. \n\nThe hash function is h(k) = k % M. \nIn case of a collision at index h(k), Linear Probing searches for the next available slot using the formula: \nh(k, i) = (h(k) + i) % M, where i = 0, 1, 2, ...\n\nYou are given the table size M and N keys to insert. If a slot is already occupied, move to the next slot linearly. If the table becomes full, stop inserting.\n\nInput Format\n- First line: Two integers M (table size) and N (number of keys).\n- Second line: N space-separated integers (keys to be inserted).\n\nOutput Format\n- Print M space-separated integers representing the final state of the hash table. \n- Use -1 to represent an empty slot.\n\nExample 1\nInput:\n7 5\n10 20 30 40 50\n\nOutput:\n-1 40 50 10 20 30 -1\n\nExplanation:\n- 10 % 7 = 3 (Slot 3)\n- 20 % 7 = 6 (Slot 6)\n- 30 % 7 = 2 (Slot 2)\n- 40 % 7 = 5 (Slot 5)\n- 50 % 7 = 1 (Slot 1)",
            "examples": "Sample Input\n5 3\n1 6 11\n\nSample Output\n-1 1 6 11 -1",
            "constraints": "1 \u00e2\u2030\u00a4 M \u00e2\u2030\u00a4 1000\n1 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 M\n0 \u00e2\u2030\u00a4 keys \u00e2\u2030\u00a4 10^9",
            "hints": 1,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 2018,
            "difficulty": 1,
            "streamId": null,
            "createdByUserId": null,
            "updatedByUserId": null,
            "testCases": [
                {
                    "id": null,
                    "problemId": null,
                    "input": "7 5\n10 20 30 40 50",
                    "expectedOutput": "-1 50 30 10 -1 40 20",
                    "problemTitle": "Linear Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "5 3\n1 6 11",
                    "expectedOutput": "-1 1 6 11 -1",
                    "problemTitle": "Linear Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "10 4\n10 20 30 40",
                    "expectedOutput": "10 20 30 40 -1 -1 -1 -1 -1 -1",
                    "problemTitle": "Linear Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "3 3\n1 2 3",
                    "expectedOutput": "3 1 2",
                    "problemTitle": "Linear Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "5 5\n0 5 10 15 20",
                    "expectedOutput": "0 5 10 15 20",
                    "problemTitle": "Linear Probing Simulation"
                }
            ],
            "starterCodes": [
                {
                    "id": null,
                    "problemId": null,
                    "language": 1,
                    "code": "def linearProbing(m, n, keys):\n    table = [-1] * m\n    # TODO: Implement Linear Probing\n    return table\n\ndef solve():\n    try:\n        line1 = input().split()\n        if not line1: return\n        m, n = map(int, line1)\n        keys = list(map(int, input().split()))\n        result = linearProbing(m, n, keys)\n        print(*(result))\n    except EOFError:\n        pass\n\nif __name__ == '__main__':\n    solve()",
                    "problemTitle": "Linear Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 2,
                    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            int[] table = new int[m];\n            Arrays.fill(table, -1);\n            \n            for (int i = 0; i < n; i++) {\n                int key = sc.nextInt();\n                // TODO: Implement Linear Probing\n            }\n            \n            for (int i = 0; i < m; i++) {\n                System.out.print(table[i] + (i == m - 1 ? \"\" : \" \"));\n            }\n            System.out.println();\n        }\n    }\n}",
                    "problemTitle": "Linear Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 3,
                    "code": "function solve(input) {\n    const lines = input.trim().split(\"\\n\");\n    if (lines.length < 2) return;\n    const [m, n] = lines[0].trim().split(/\\s+/).map(Number);\n    const keys = lines[1].trim().split(/\\s+/).map(Number);\n    \n    let table = new Array(m).fill(-1);\n    // TODO: Implement Linear Probing\n    \n    console.log(table.join(\" \"));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));",
                    "problemTitle": "Linear Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 4,
                    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int m, n;\n    if (cin >> m >> n) {\n        vector<int> table(m, -1);\n        for (int i = 0; i < n; i++) {\n            int key;\n            cin >> key;\n            // TODO: Implement Linear Probing\n        }\n        for (int i = 0; i < m; i++) {\n            cout << table[i] << (i == m - 1 ? \"\" : \" \");\n        }\n        cout << endl;\n    }\n    return 0;\n}",
                    "problemTitle": "Linear Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 5,
                    "code": "#include <stdio.h>\n\nint main() {\n    int m, n;\n    if (scanf(\"%d %d\", &m, &n) != EOF) {\n        int table[m];\n        for (int i = 0; i < m; i++) table[i] = -1;\n        for (int i = 0; i < n; i++) {\n            int key;\n            scanf(\"%d\", &key);\n            // TODO: Implement Linear Probing\n        }\n        for (int i = 0; i < m; i++) {\n            printf(\"%d%s\", table[i], (i == m - 1 ? \"\" : \" \"));\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
                    "problemTitle": "Linear Probing Simulation"
                }
            ],
            "hintsList": [
                "Calculate the initial hash index using key % M.",
                "If the slot is occupied, check (index + 1) % M, (index + 2) % M, and so on.",
                "Stop when you find an empty slot (-1)."
            ]
        },
        {
            "id": null,
            "title": "Quadratic Probing Simulation",
            "description": "Problem Statement\nImplement a hash table of size M using Quadratic Probing for collision resolution. \n\nThe hash function is h(k) = k % M. \nIn case of a collision at index h(k), Quadratic Probing searches for the next available slot using the formula: \nh(k, i) = (h(k) + i^2) % M, where i = 0, 1, 2, ...\n\nYou are given the table size M and N keys to insert. If a slot is already occupied, increment i and check the next quadratic position. If the table becomes full or you cannot find a slot within M attempts, stop inserting for that key.\n\nInput Format\n- First line: Two integers M (table size) and N (number of keys).\n- Second line: N space-separated integers (keys to be inserted).\n\nOutput Format\n- Print M space-separated integers representing the final state of the hash table. \n- Use -1 to represent an empty slot.\n\nExample 1\nInput:\n7 3\n10 17 24\n\nOutput:\n-1 -1 -1 10 17 24 -1\n\nExplanation:\n- 10 % 7 = 3 (Slot 3)\n- 17 % 7 = 3 (Collision). Try (3 + 1^2) % 7 = 4 (Slot 4)\n- 24 % 7 = 3 (Collision). Try (3 + 1^2) % 7 = 4 (Collision). Try (3 + 2^2) % 7 = 0 (Collision - wait, 3+4=7, 7%7=0). Slot 0.",
            "examples": "Sample Input\n5 2\n1 6\n\nSample Output\n-1 1 2 -1 -1 (Wait, 6%5=1, collision. (1+1^2)%5=2. So 1 at index 1, 6 at index 2)",
            "constraints": "1 \u00e2\u2030\u00a4 M \u00e2\u2030\u00a4 1000\n1 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 M\n0 \u00e2\u2030\u00a4 keys \u00e2\u2030\u00a4 10^9",
            "hints": 2,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 2018,
            "difficulty": 2,
            "streamId": null,
            "createdByUserId": null,
            "updatedByUserId": null,
            "testCases": [
                {
                    "id": null,
                    "problemId": null,
                    "input": "7 3\n10 17 24",
                    "expectedOutput": "24 -1 -1 10 17 -1 -1",
                    "problemTitle": "Quadratic Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "5 2\n1 6",
                    "expectedOutput": "-1 1 6 -1 -1",
                    "problemTitle": "Quadratic Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "10 3\n10 20 30",
                    "expectedOutput": "10 20 -1 -1 30 -1 -1 -1 -1 -1",
                    "problemTitle": "Quadratic Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "11 3\n1 12 23",
                    "expectedOutput": "-1 1 12 -1 -1 23 -1 -1 -1 -1 -1",
                    "problemTitle": "Quadratic Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "3 2\n1 4",
                    "expectedOutput": "-1 1 4",
                    "problemTitle": "Quadratic Probing Simulation"
                }
            ],
            "starterCodes": [
                {
                    "id": null,
                    "problemId": null,
                    "language": 1,
                    "code": "def quadraticProbing(m, n, keys):\n    table = [-1] * m\n    # TODO: Implement Quadratic Probing\n    return table\n\ndef solve():\n    try:\n        line1 = input().split()\n        if not line1: return\n        m, n = map(int, line1)\n        keys = list(map(int, input().split()))\n        result = quadraticProbing(m, n, keys)\n        print(*(result))\n    except EOFError:\n        pass\n\nif __name__ == '__main__':\n    solve()",
                    "problemTitle": "Quadratic Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 2,
                    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            int[] table = new int[m];\n            Arrays.fill(table, -1);\n            \n            for (int i = 0; i < n; i++) {\n                int key = sc.nextInt();\n                // TODO: Implement Quadratic Probing\n            }\n            \n            for (int i = 0; i < m; i++) {\n                System.out.print(table[i] + (i == m - 1 ? \"\" : \" \"));\n            }\n            System.out.println();\n        }\n    }\n}",
                    "problemTitle": "Quadratic Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 3,
                    "code": "function solve(input) {\n    const lines = input.trim().split(\"\\n\");\n    if (lines.length < 2) return;\n    const [m, n] = lines[0].trim().split(/\\s+/).map(Number);\n    const keys = lines[1].trim().split(/\\s+/).map(Number);\n    \n    let table = new Array(m).fill(-1);\n    // TODO: Implement Quadratic Probing\n    \n    console.log(table.join(\" \"));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));",
                    "problemTitle": "Quadratic Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 4,
                    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int m, n;\n    if (cin >> m >> n) {\n        vector<int> table(m, -1);\n        for (int i = 0; i < n; i++) {\n            int key;\n            cin >> key;\n            // TODO: Implement Quadratic Probing\n        }\n        for (int i = 0; i < m; i++) {\n            cout << table[i] << (i == m - 1 ? \"\" : \" \");\n        }\n        cout << endl;\n    }\n    return 0;\n}",
                    "problemTitle": "Quadratic Probing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 5,
                    "code": "#include <stdio.h>\n\nint main() {\n    int m, n;\n    if (scanf(\"%d %d\", &m, &n) != EOF) {\n        int table[m];\n        for (int i = 0; i < m; i++) table[i] = -1;\n        for (int i = 0; i < n; i++) {\n            int key;\n            scanf(\"%d\", &key);\n            // TODO: Implement Quadratic Probing\n        }\n        for (int i = 0; i < m; i++) {\n            printf(\"%d%s\", table[i], (i == m - 1 ? \"\" : \" \"));\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
                    "problemTitle": "Quadratic Probing Simulation"
                }
            ],
            "hintsList": [
                "Calculate the initial hash index using key % M.",
                "If the slot is occupied, check (index + i*i) % M for i = 1, 2, 3...",
                "Be careful with large values of i*i; use modulo at each step."
            ]
        },
        {
            "id": null,
            "title": "Double Hashing Simulation",
            "description": "Problem Statement\nImplement a hash table of size M using Double Hashing for collision resolution. \n\nThe primary hash function is h1(k) = k % M. \nThe secondary hash function is h2(k) = P - (k % P), where P is a prime number smaller than M.\n\nIn case of a collision at index h1(k), Double Hashing searches for the next available slot using the formula: \nh(k, i) = (h1(k) + i * h2(k)) % M, where i = 0, 1, 2, ...\n\nYou are given M, P, and N keys to insert. If a slot is already occupied, increment i and check the next position. If the table becomes full, stop inserting.\n\nInput Format\n- First line: Three integers M (table size), P (prime for h2), and N (number of keys).\n- Second line: N space-separated integers (keys to be inserted).\n\nOutput Format\n- Print M space-separated integers representing the final state of the hash table. \n- Use -1 to represent an empty slot.\n\nExample 1\nInput:\n7 5 3\n10 17 24\n\nOutput:\n-1 -1 24 10 17 -1 -1\n\nExplanation:\n- 10 % 7 = 3 (Slot 3)\n- 17 % 7 = 3 (Collision). h2(17) = 5 - (17 % 5) = 5 - 2 = 3. Try (3 + 1*3) % 7 = 6 (Slot 6)\n- 24 % 7 = 3 (Collision). h2(24) = 5 - (24 % 5) = 5 - 4 = 1. Try (3 + 1*1) % 7 = 4 (Slot 4)",
            "examples": "Sample Input\n5 3 2\n1 6\n\nSample Output\n-1 1 -1 6 -1",
            "constraints": "1 \u00e2\u2030\u00a4 M \u00e2\u2030\u00a4 1000\n1 \u00e2\u2030\u00a4 P < M\n1 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 M\n0 \u00e2\u2030\u00a4 keys \u00e2\u2030\u00a4 10^9",
            "hints": 2,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 2018,
            "difficulty": 2,
            "streamId": null,
            "createdByUserId": null,
            "updatedByUserId": null,
            "testCases": [
                {
                    "id": null,
                    "problemId": null,
                    "input": "7 5 3\n10 17 24",
                    "expectedOutput": "-1 -1 -1 10 24 -1 17",
                    "problemTitle": "Double Hashing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "5 3 2\n1 6",
                    "expectedOutput": "-1 1 -1 -1 6",
                    "problemTitle": "Double Hashing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "11 7 4\n11 22 33 44",
                    "expectedOutput": "11 -1 33 -1 -1 44 22 -1 -1 -1 -1",
                    "problemTitle": "Double Hashing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "13 7 3\n1 14 27",
                    "expectedOutput": "-1 1 27 -1 -1 -1 -1 -1 14 -1 -1 -1 -1",
                    "problemTitle": "Double Hashing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "5 3 5\n0 5 10 15 20",
                    "expectedOutput": "0 5 10 15 20",
                    "problemTitle": "Double Hashing Simulation"
                }
            ],
            "starterCodes": [
                {
                    "id": null,
                    "problemId": null,
                    "language": 1,
                    "code": "def doubleHashing(m, p, n, keys):\n    table = [-1] * m\n    # TODO: Implement Double Hashing\n    return table\n\ndef solve():\n    try:\n        line1 = input().split()\n        if not line1: return\n        m, p, n = map(int, line1)\n        keys = list(map(int, input().split()))\n        result = doubleHashing(m, p, n, keys)\n        print(*(result))\n    except EOFError:\n        pass\n\nif __name__ == '__main__':\n    solve()",
                    "problemTitle": "Double Hashing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 2,
                    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int m = sc.nextInt();\n            int p = sc.nextInt();\n            int n = sc.nextInt();\n            int[] table = new int[m];\n            Arrays.fill(table, -1);\n            \n            for (int i = 0; i < n; i++) {\n                int key = sc.nextInt();\n                // TODO: Implement Double Hashing\n            }\n            \n            for (int i = 0; i < m; i++) {\n                System.out.print(table[i] + (i == m - 1 ? \"\" : \" \"));\n            }\n            System.out.println();\n        }\n    }\n}",
                    "problemTitle": "Double Hashing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 3,
                    "code": "function solve(input) {\n    const lines = input.trim().split(\"\\n\");\n    if (lines.length < 2) return;\n    const [m, p, n] = lines[0].trim().split(/\\s+/).map(Number);\n    const keys = lines[1].trim().split(/\\s+/).map(Number);\n    \n    let table = new Array(m).fill(-1);\n    // TODO: Implement Double Hashing\n    \n    console.log(table.join(\" \"));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));",
                    "problemTitle": "Double Hashing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 4,
                    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int m, p, n;\n    if (cin >> m >> p >> n) {\n        vector<int> table(m, -1);\n        for (int i = 0; i < n; i++) {\n            int key;\n            cin >> key;\n            // TODO: Implement Double Hashing\n        }\n        for (int i = 0; i < m; i++) {\n            cout << table[i] << (i == m - 1 ? \"\" : \" \");\n        }\n        cout << endl;\n    }\n    return 0;\n}",
                    "problemTitle": "Double Hashing Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 5,
                    "code": "#include <stdio.h>\n\nint main() {\n    int m, p, n;\n    if (scanf(\"%d %d %d\", &m, &p, &n) != EOF) {\n        int table[m];\n        for (int i = 0; i < m; i++) table[i] = -1;\n        for (int i = 0; i < n; i++) {\n            int key;\n            scanf(\"%d\", &key);\n            // TODO: Implement Double Hashing\n        }\n        for (int i = 0; i < m; i++) {\n            printf(\"%d%s\", table[i], (i == m - 1 ? \"\" : \" \"));\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}",
                    "problemTitle": "Double Hashing Simulation"
                }
            ],
            "hintsList": [
                "h1(k) = k % M and h2(k) = P - (k % P).",
                "If a collision occurs at h1(k), check (h1(k) + 1*h2(k)) % M, then (h1(k) + 2*h2(k)) % M, and so on.",
                "The secondary hash h2(k) must never be zero."
            ]
        },
        {
            "id": null,
            "title": "Separate Chaining Simulation",
            "description": "Problem Statement\nImplement a hash table of size M using Separate Chaining for collision resolution. \n\nThe hash function is h(k) = k % M. \nIn case of a collision, the key is appended to a linked list (or dynamic array) at that index. New keys should be added to the end of the list.\n\nYou are given the table size M and N keys to insert.\n\nInput Format\n- First line: Two integers M (table size) and N (number of keys).\n- Second line: N space-separated integers (keys to be inserted).\n\nOutput Format\n- Print M lines. Each line should start with the index followed by a colon and a space, then the keys at that index separated by spaces.\n- Format: \"Index i: key1 key2 ...\"\n\nExample 1\nInput:\n5 5\n10 11 15 20 6\n\nOutput:\nIndex 0: 10 15 20\nIndex 1: 11 6\nIndex 2: \nIndex 3: \nIndex 4: \n\nExplanation:\n- 10 % 5 = 0\n- 11 % 5 = 1\n- 15 % 5 = 0\n- 20 % 5 = 0\n- 6 % 5 = 1",
            "examples": "Sample Input\n3 3\n1 2 3\n\nSample Output\nIndex 0: 3\nIndex 1: 1\nIndex 2: 2",
            "constraints": "1 \u00e2\u2030\u00a4 M \u00e2\u2030\u00a4 100\n1 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 500\n0 \u00e2\u2030\u00a4 keys \u00e2\u2030\u00a4 10^9",
            "hints": 2,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 2018,
            "difficulty": 2,
            "streamId": null,
            "createdByUserId": null,
            "updatedByUserId": null,
            "testCases": [
                {
                    "id": null,
                    "problemId": null,
                    "input": "5 5\n10 11 15 20 6",
                    "expectedOutput": "Index 0: 10 15 20\nIndex 1: 11 6\nIndex 2: \nIndex 3: \nIndex 4:",
                    "problemTitle": "Separate Chaining Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "3 3\n1 2 3",
                    "expectedOutput": "Index 0: 3\nIndex 1: 1\nIndex 2: 2",
                    "problemTitle": "Separate Chaining Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "4 6\n4 8 12 1 5 9",
                    "expectedOutput": "Index 0: 4 8 12\nIndex 1: 1 5 9\nIndex 2: \nIndex 3:",
                    "problemTitle": "Separate Chaining Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "1 3\n10 20 30",
                    "expectedOutput": "Index 0: 10 20 30",
                    "problemTitle": "Separate Chaining Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "6 0\n",
                    "expectedOutput": "Index 0: \nIndex 1: \nIndex 2: \nIndex 3: \nIndex 4: \nIndex 5:",
                    "problemTitle": "Separate Chaining Simulation"
                }
            ],
            "starterCodes": [
                {
                    "id": null,
                    "problemId": null,
                    "language": 1,
                    "code": "def separateChaining(m, n, keys):\n    table = [[] for _ in range(m)]\n    # TODO: Implement Separate Chaining\n    return table\n\ndef solve():\n    try:\n        line1 = input().split()\n        if not line1: return\n        m, n = map(int, line1)\n        if n > 0:\n            keys = list(map(int, input().split()))\n        else:\n            keys = []\n        result = separateChaining(m, n, keys)\n        for i in range(m):\n            print(f\"Index {i}: {' '.join(map(str, result[i]))}\")\n    except EOFError:\n        pass\n\nif __name__ == '__main__':\n    solve()",
                    "problemTitle": "Separate Chaining Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 2,
                    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            List<Integer>[] table = new ArrayList[m];\n            for (int i = 0; i < m; i++) table[i] = new ArrayList<>();\n            \n            for (int i = 0; i < n; i++) {\n                int key = sc.nextInt();\n                // TODO: Implement Separate Chaining\n            }\n            \n            for (int i = 0; i < m; i++) {\n                System.out.print(\"Index \" + i + \": \");\n                for (int j = 0; j < table[i].size(); j++) {\n                    System.out.print(table[i].get(j) + (j == table[i].size() - 1 ? \"\" : \" \"));\n                }\n                System.out.println();\n            }\n        }\n    }\n}",
                    "problemTitle": "Separate Chaining Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 3,
                    "code": "function solve(input) {\n    const lines = input.trim().split(\"\\n\");\n    if (lines.length < 1) return;\n    const [m, n] = lines[0].trim().split(/\\s+/).map(Number);\n    const keys = n > 0 ? lines[1].trim().split(/\\s+/).map(Number) : [];\n    \n    let table = Array.from({ length: m }, () => []);\n    // TODO: Implement Separate Chaining\n    \n    for (let i = 0; i < m; i++) {\n        console.log(`Index ${i}: ${table[i].join(\" \")}`);\n    }\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));",
                    "problemTitle": "Separate Chaining Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 4,
                    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int m, n;\n    if (cin >> m >> n) {\n        vector<vector<int>> table(m);\n        for (int i = 0; i < n; i++) {\n            int key;\n            cin >> key;\n            // TODO: Implement Separate Chaining\n        }\n        for (int i = 0; i < m; i++) {\n            cout << \"Index \" << i << \": \";\n            for (int j = 0; j < table[i].size(); j++) {\n                cout << table[i][j] << (j == table[i].size() - 1 ? \"\" : \" \");\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}",
                    "problemTitle": "Separate Chaining Simulation"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node {\n    int key;\n    struct Node* next;\n};\n\nint main() {\n    int m, n;\n    if (scanf(\"%d %d\", &m, &n) != EOF) {\n        struct Node* table[m];\n        for (int i = 0; i < m; i++) table[i] = NULL;\n        \n        for (int i = 0; i < n; i++) {\n            int key;\n            scanf(\"%d\", &key);\n            // TODO: Implement Separate Chaining (Add to end of list)\n        }\n        \n        for (int i = 0; i < m; i++) {\n            printf(\"Index %d: \", i);\n            struct Node* curr = table[i];\n            while (curr) {\n                printf(\"%d%s\", curr->key, (curr->next ? \" \" : \"\"));\n                curr = curr->next;\n            }\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}",
                    "problemTitle": "Separate Chaining Simulation"
                }
            ],
            "hintsList": [
                "Use an array of lists or an array of pointers to linked lists.",
                "The hash index is key % M.",
                "Append each new key to the end of the list at its hash index."
            ]
        },
        {
            "id": null,
            "title": "Count Distinct Elements",
            "description": "Problem Statement\nYou are given an array of N integers. Your task is to count the number of distinct (unique) elements in the array using a hashing-based approach.\n\nInput Format\n- First line: An integer N (number of elements).\n- Second line: N space-separated integers.\n\nOutput Format\n- Print a single integer representing the count of distinct elements.\n\nExample 1\nInput:\n6\n10 20 10 30 20 40\n\nOutput:\n4\n\nExplanation:\nThe distinct elements are 10, 20, 30, and 40.",
            "examples": "Sample Input\n5\n1 1 1 1 1\n\nSample Output\n1",
            "constraints": "1 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10^5\n-10^9 \u00e2\u2030\u00a4 A[i] \u00e2\u2030\u00a4 10^9",
            "hints": 1,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 2018,
            "difficulty": 1,
            "streamId": null,
            "createdByUserId": null,
            "updatedByUserId": null,
            "testCases": [
                {
                    "id": null,
                    "problemId": null,
                    "input": "6\n10 20 10 30 20 40",
                    "expectedOutput": "4",
                    "problemTitle": "Count Distinct Elements"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "5\n1 1 1 1 1",
                    "expectedOutput": "1",
                    "problemTitle": "Count Distinct Elements"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "4\n1 2 3 4",
                    "expectedOutput": "4",
                    "problemTitle": "Count Distinct Elements"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "1\n100",
                    "expectedOutput": "1",
                    "problemTitle": "Count Distinct Elements"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "8\n-1 0 -1 2 0 3 2 4",
                    "expectedOutput": "5",
                    "problemTitle": "Count Distinct Elements"
                }
            ],
            "starterCodes": [
                {
                    "id": null,
                    "problemId": null,
                    "language": 1,
                    "code": "def countDistinct(arr, n):\n    # TODO: Use a hash set to count distinct elements\n    return 0\n\ndef solve():\n    try:\n        n = int(input().strip())\n        arr = list(map(int, input().split()))\n        print(countDistinct(arr, n))\n    except EOFError:\n        pass\n\nif __name__ == '__main__':\n    solve()",
                    "problemTitle": "Count Distinct Elements"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 2,
                    "code": "import java.util.*;\n\npublic class Solution {\n    public static int countDistinct(int[] arr, int n) {\n        // TODO: Use a HashSet to count distinct elements\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();\n            System.out.println(countDistinct(arr, n));\n        }\n    }\n}",
                    "problemTitle": "Count Distinct Elements"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 3,
                    "code": "function countDistinct(arr, n) {\n    // TODO: Use a Set to count distinct elements\n    return 0;\n}\n\nfunction solve(input) {\n    const lines = input.trim().split(\"\\n\");\n    if (lines.length < 2) return;\n    const n = Number(lines[0].trim());\n    const arr = lines[1].trim().split(/\\s+/).map(Number);\n    console.log(countDistinct(arr, n));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));",
                    "problemTitle": "Count Distinct Elements"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 4,
                    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint countDistinct(vector<int>& arr, int n) {\n    // TODO: Use unordered_set to count distinct elements\n    return 0;\n}\n\nint main() {\n    int n;\n    if (cin >> n) {\n        vector<int> arr(n);\n        for (int i = 0; i < n; i++) cin >> arr[i];\n        cout << countDistinct(arr, n) << endl;\n    }\n    return 0;\n}",
                    "problemTitle": "Count Distinct Elements"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 5,
                    "code": "#include <stdio.h>\n\n// In C, you might need a simple hash table or sort the array\n// For this problem, assume a simple approach is needed\nint countDistinct(int arr[], int n) {\n    // TODO: Count distinct elements\n    return 0;\n}\n\nint main() {\n    int n;\n    if (scanf(\"%d\", &n) != EOF) {\n        int arr[n];\n        for (int i = 0; i < n; i++) scanf(\"%d\", &arr[i]);\n        printf(\"%d\\n\", countDistinct(arr, n));\n    }\n    return 0;\n}",
                    "problemTitle": "Count Distinct Elements"
                }
            ],
            "hintsList": [
                "A Hash Set automatically handles duplicate elements.",
                "Insert all elements into the set and return its size.",
                "In C++, use unordered_set; in Java, use HashSet; in Python, use set()."
            ]
        },
        {
            "id": null,
            "title": "First Repeating Element",
            "description": "Problem Statement\nGiven an array of N integers, find the first repeating element. An element is repeating if it appears more than once in the array. The \"first\" repeating element is the one whose first occurrence has the smallest index.\n\nIf there are no repeating elements, print -1.\n\nInput Format\n- First line: An integer N (number of elements).\n- Second line: N space-separated integers.\n\nOutput Format\n- Print the value of the first repeating element. If none, print -1.\n\nExample 1\nInput:\n7\n10 5 3 4 3 5 6\n\nOutput:\n5\n\nExplanation:\n- 5 repeats (first seen at index 1)\n- 3 repeats (first seen at index 2)\nSince index 1 is smaller than index 2, the answer is 5.",
            "examples": "Sample Input\n4\n1 2 3 4\n\nSample Output\n-1",
            "constraints": "1 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10^5\n-10^9 \u00e2\u2030\u00a4 A[i] \u00e2\u2030\u00a4 10^9",
            "hints": 2,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 2018,
            "difficulty": 2,
            "streamId": null,
            "createdByUserId": null,
            "updatedByUserId": null,
            "testCases": [
                {
                    "id": null,
                    "problemId": null,
                    "input": "7\n10 5 3 4 3 5 6",
                    "expectedOutput": "5",
                    "problemTitle": "First Repeating Element"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "4\n1 2 3 4",
                    "expectedOutput": "-1",
                    "problemTitle": "First Repeating Element"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "6\n1 2 2 1 3 3",
                    "expectedOutput": "1",
                    "problemTitle": "First Repeating Element"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "5\n10 20 30 20 10",
                    "expectedOutput": "10",
                    "problemTitle": "First Repeating Element"
                },
                {
                    "id": null,
                    "problemId": null,
                    "input": "3\n5 5 5",
                    "expectedOutput": "5",
                    "problemTitle": "First Repeating Element"
                }
            ],
            "starterCodes": [
                {
                    "id": null,
                    "problemId": null,
                    "language": 1,
                    "code": "def firstRepeating(arr, n):\n    # TODO: Find the first repeating element using hashing\n    return -1\n\ndef solve():\n    try:\n        n = int(input().strip())\n        arr = list(map(int, input().split()))\n        print(firstRepeating(arr, n))\n    except EOFError:\n        pass\n\nif __name__ == '__main__':\n    solve()",
                    "problemTitle": "First Repeating Element"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 2,
                    "code": "import java.util.*;\n\npublic class Solution {\n    public static int firstRepeating(int[] arr, int n) {\n        // TODO: Find the first repeating element using hashing\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        if (sc.hasNextInt()) {\n            int n = sc.nextInt();\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();\n            System.out.println(firstRepeating(arr, n));\n        }\n    }\n}",
                    "problemTitle": "First Repeating Element"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 3,
                    "code": "function firstRepeating(arr, n) {\n    // TODO: Find the first repeating element using hashing\n    return -1;\n}\n\nfunction solve(input) {\n    const lines = input.trim().split(\"\\n\");\n    if (lines.length < 2) return;\n    const n = Number(lines[0].trim());\n    const arr = lines[1].trim().split(/\\s+/).map(Number);\n    console.log(firstRepeating(arr, n));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));",
                    "problemTitle": "First Repeating Element"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 4,
                    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint firstRepeating(vector<int>& arr, int n) {\n    // TODO: Find the first repeating element using hashing\n    return -1;\n}\n\nint main() {\n    int n;\n    if (cin >> n) {\n        vector<int> arr(n);\n        for (int i = 0; i < n; i++) cin >> arr[i];\n        cout << firstRepeating(arr, n) << endl;\n    }\n    return 0;\n}",
                    "problemTitle": "First Repeating Element"
                },
                {
                    "id": null,
                    "problemId": null,
                    "language": 5,
                    "code": "#include <stdio.h>\n\nint firstRepeating(int arr[], int n) {\n    // TODO: Find the first repeating element using hashing\n    return -1;\n}\n\nint main() {\n    int n;\n    if (scanf(\"%d\", &n) != EOF) {\n        int arr[n];\n        for (int i = 0; i < n; i++) scanf(\"%d\", &arr[i]);\n        printf(\"%d\\n\", firstRepeating(arr, n));\n    }\n    return 0;\n}",
                    "problemTitle": "First Repeating Element"
                }
            ],
            "hintsList": [
                "Use a hash map to store the frequency of each element.",
                "Traverse the array again and check the frequency of each element in the map.",
                "The first element with a frequency greater than 1 is the answer."
            ]
        }
    ]
}