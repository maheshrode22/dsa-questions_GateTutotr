{
  "problems": [
    {
      "id": null,
      "title": "Radix Sort for Non-Negative Integers",
      "description": "Problem Statement\nYou are given an integer N and an array A containing N non-negative integers. Your task is to sort the array in ascending order using the Radix Sort algorithm.\nRadix Sort processes digits one by one (least significant digit first) using a stable counting sort as a subroutine. Continue digit-wise sorting until all digits are processed.\n\nInput Format\nThe first line contains an integer N.\nThe second line contains N space-separated non-negative integers representing the array A.\n\nOutput Format\nPrint the sorted array in ascending order.\n\nExample 1\nInput:\n7\n170 45 75 90 802 24 2\n\nOutput:\n2 24 45 75 90 170 802\n\nExplanation:\nDigits are processed level-by-level, sorting values by each digit from rightmost to leftmost.",
      "examples": "Sample Input\n5\n90 802 2 24 66\n\nSample Output\n2 24 66 90 802",
      "constraints": "1 ≤ N ≤ 10^5\n0 ≤ A[i] ≤ 10^9",
      "hints": 2,
      "timeLimit": 1,
      "memoryLimit": 256,
      "subdomainId": 2016,
      "difficulty": 3,
      "streamId": null,
      "createdByUserId": null,
      "updatedByUserId": null,

      "testCases": [
        { "id": null, "problemId": null, "input": "7\n170 45 75 90 802 24 2", "expectedOutput": "2 24 45 75 90 170 802", "problemTitle": "Radix Sort for Non-Negative Integers" },
        { "id": null, "problemId": null, "input": "5\n90 802 2 24 66", "expectedOutput": "2 24 66 90 802", "problemTitle": "Radix Sort for Non-Negative Integers" },
        { "id": null, "problemId": null, "input": "1\n500", "expectedOutput": "500", "problemTitle": "Radix Sort for Non-Negative Integers" },
        { "id": null, "problemId": null, "input": "6\n5 3 8 6 2 1", "expectedOutput": "1 2 3 5 6 8", "problemTitle": "Radix Sort for Non-Negative Integers" },
        { "id": null, "problemId": null, "input": "6\n1000 50 0 900 12 3", "expectedOutput": "0 3 12 50 900 1000", "problemTitle": "Radix Sort for Non-Negative Integers" }
      ],

      "starterCodes": [
        {
          "id": null,
          "problemId": null,
          "language": 1,
          "code": "def radixSort(arr):\n    # TODO: Implement Radix Sort for non-negative integers using digit-wise stable sorting\n    return arr\n\ndef solve():\n    n = int(input().strip())\n    arr = list(map(int, input().split()))\n    sortedArr = radixSort(arr)\n    print(*sortedArr)\n\nif __name__ == '__main__':\n    solve()",
          "problemTitle": "Radix Sort for Non-Negative Integers"
        },
        {
          "id": null,
          "problemId": null,
          "language": 2,
          "code": "import java.io.*;\nimport java.util.*;\n\nclass Result {\n    public static void radixSort(int[] arr) {\n        // TODO: Implement Radix Sort using counting sort per digit\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine().trim());\n        int[] arr = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Result.radixSort(arr);\n        for(int x : arr) System.out.print(x + \" \");\n    }\n}",
          "problemTitle": "Radix Sort for Non-Negative Integers"
        },
        {
          "id": null,
          "problemId": null,
          "language": 3,
          "code": "function radixSort(arr) {\n    // TODO: Implement Radix Sort (LSD) using stable count sort\n    return arr;\n}\n\nfunction solve(input) {\n    const lines = input.trim().split(\"\\n\");\n    const arr = lines[1].split(\" \").map(Number);\n    const sortedArr = radixSort(arr);\n    console.log(sortedArr.join(\" \"));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));",
          "problemTitle": "Radix Sort for Non-Negative Integers"
        },
        {
          "id": null,
          "problemId": null,
          "language": 4,
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid radixSort(vector<long long>& arr) {\n    // TODO: Implement Radix Sort logic using digit processing\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    vector<long long> arr(n);\n    for(int i = 0; i < n; i++) cin >> arr[i];\n    radixSort(arr);\n    for(long long x : arr) cout << x << \" \";\n    return 0;\n}",
          "problemTitle": "Radix Sort for Non-Negative Integers"
        },
        {
          "id": null,
          "problemId": null,
          "language": 5,
          "code": "#include <stdio.h>\n\nvoid radixSort(long long arr[], int n) {\n    // TODO: Perform radix sort digit-by-digit using counting sort\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    long long arr[100001];\n    for(int i = 0; i < n; i++) scanf(\"%lld\", &arr[i]);\n    radixSort(arr, n);\n    for(int i = 0; i < n; i++) printf(\"%lld \", arr[i]);\n    return 0;\n}",
          "problemTitle": "Radix Sort for Non-Negative Integers"
        }
      ],

      "hintsList": [
        "Find maximum element to determine number of digit passes",
        "Use stable counting sort for each digit (place calculation: (num / exp) % 10)"
      ]
    },
     {
      "id": null,
      "title": "Counting Sort + Stability Check",
      "description": "Problem Statement\nYou are given an integer N and an array A of N non-negative integers. Your task is to apply Counting Sort to sort the array in ascending order, ensuring the sorting is stable.\nAfter sorting, print the sorted array. Then check and print whether the sorting performed is Stable or Unstable. A sorting technique is considered stable if elements with the same value appear in the same relative order as before sorting.\n\nInput Format\nThe first line contains an integer N.\nThe second line contains N space-separated non-negative integers representing the array A.\n\nOutput Format\nFirst print the sorted array.\nOn the next line, print \"Stable\" if the counting sort maintained order of equal values, otherwise print \"Unstable\".\n\nExample 1\nInput:\n7\n4 2 3 2 4 3 1\n\nOutput:\n1 2 2 3 3 4 4\nStable\n\nExplanation:\nAfter sorting, equal elements preserve their order; therefore, the result is Stable.",
      "examples": "Sample Input\n6\n1 4 2 4 1 3\n\nSample Output\n1 1 2 3 4 4\nStable",
      "constraints": "1 ≤ N ≤ 10^5\n0 ≤ A[i] ≤ 10^5",
      "hints": 2,
      "timeLimit": 1,
      "memoryLimit": 256,
      "subdomainId": 2016,
      "difficulty": 3,
      "streamId": null,
      "createdByUserId": null,
      "updatedByUserId": null,

      "testCases": [
        { "id": null, "problemId": null, "input": "7\n4 2 3 2 4 3 1", "expectedOutput": "1 2 2 3 3 4 4\nStable", "problemTitle": "Counting Sort + Stability Check" },
        { "id": null, "problemId": null, "input": "6\n1 4 2 4 1 3", "expectedOutput": "1 1 2 3 4 4\nStable", "problemTitle": "Counting Sort + Stability Check" },
        { "id": null, "problemId": null, "input": "5\n5 4 3 2 1", "expectedOutput": "1 2 3 4 5\nStable", "problemTitle": "Counting Sort + Stability Check" },
        { "id": null, "problemId": null, "input": "7\n3 3 3 3 3 3 3", "expectedOutput": "3 3 3 3 3 3 3\nStable", "problemTitle": "Counting Sort + Stability Check" },
        { "id": null, "problemId": null, "input": "6\n2 1 2 1 2 1", "expectedOutput": "1 1 1 2 2 2\nStable", "problemTitle": "Counting Sort + Stability Check" }
      ],

      "starterCodes": [
        {
          "id": null,
          "problemId": null,
          "language": 1,
          "code": "def countingSortStable(arr):\n    # TODO: Implement stable Counting Sort and return sorted array\n    return arr\n\ndef checkStability(original, sortedArr):\n    # TODO: Determine if relative order of duplicates is preserved\n    return \"Stable\"\n\ndef solve():\n    n = int(input().strip())\n    arr = list(map(int, input().split()))\n    original = arr.copy()\n    sortedArr = countingSortStable(arr)\n    print(*sortedArr)\n    print(checkStability(original, sortedArr))\n\nif __name__ == '__main__':\n    solve()",
          "problemTitle": "Counting Sort + Stability Check"
        },
        {
          "id": null,
          "problemId": null,
          "language": 2,
          "code": "import java.io.*;\nimport java.util.*;\n\nclass Result {\n    public static int[] countingSortStable(int[] arr) {\n        // TODO: Implement stable Counting Sort\n        return arr;\n    }\n    public static String checkStability(int[] original, int[] sortedArr) {\n        // TODO: Check if equal values maintain original order\n        return \"Stable\";\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine().trim());\n        int[] arr = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int[] original = arr.clone();\n        int[] sortedArr = Result.countingSortStable(arr);\n        for(int x : sortedArr) System.out.print(x + \" \");\n        System.out.println();\n        System.out.println(Result.checkStability(original, sortedArr));\n    }\n}",
          "problemTitle": "Counting Sort + Stability Check"
        },
        {
          "id": null,
          "problemId": null,
          "language": 3,
          "code": "function countingSortStable(arr) {\n    // TODO: Implement stable counting sort algorithm\n    return arr;\n}\n\nfunction checkStability(original, sortedArr) {\n    // TODO: Check duplicate order stability\n    return \"Stable\";\n}\n\nfunction solve(input) {\n    const lines = input.trim().split(\"\\n\");\n    const arr = lines[1].split(\" \").map(Number);\n    const original = [...arr];\n    const sortedArr = countingSortStable(arr);\n    console.log(sortedArr.join(\" \"));\n    console.log(checkStability(original, sortedArr));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));",
          "problemTitle": "Counting Sort + Stability Check"
        },
        {
          "id": null,
          "problemId": null,
          "language": 4,
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<long long> countingSortStable(vector<long long> arr) {\n    // TODO: Implement stable counting sort logic\n    return arr;\n}\n\nstring checkStability(vector<long long> original, vector<long long> sortedArr) {\n    // TODO: Verify if order of identical values is preserved\n    return \"Stable\";\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    vector<long long> arr(n), original(n);\n    for(int i = 0; i < n; i++) cin >> arr[i];\n    original = arr;\n    vector<long long> sortedArr = countingSortStable(arr);\n    for(long long x : sortedArr) cout << x << \" \";\n    cout << \"\\n\" << checkStability(original, sortedArr);\n    return 0;\n}",
          "problemTitle": "Counting Sort + Stability Check"
        },
        {
          "id": null,
          "problemId": null,
          "language": 5,
          "code": "#include <stdio.h>\n#include <string.h>\n\nvoid countingSortStable(long long arr[], int n) {\n    // TODO: Implement stable counting sort here\n}\n\nconst char* checkStability(long long original[], long long sortedArr[], int n) {\n    // TODO: Check stability of equal values\n    return \"Stable\";\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    long long arr[100001], original[100001];\n    for(int i = 0; i < n; i++) scanf(\"%lld\", &arr[i]);\n    memcpy(original, arr, sizeof(long long) * n);\n    countingSortStable(arr, n);\n    for(int i = 0; i < n; i++) printf(\"%lld \", arr[i]);\n    printf(\"\\n%s\", checkStability(original, arr, n));\n    return 0;\n}",
          "problemTitle": "Counting Sort + Stability Check"
        }
      ],

      "hintsList": [
        "Use stable ordering when placing values into output array (traverse from end)",
        "Track indices of duplicates to verify stability"
      ]
    },
    {
      "id": null,
      "title": "Hybrid Sorting (Quick + Insertion for Small Partitions)",
      "description": "Problem Statement\nYou are given an integer N and an array A of N integers. Your task is to sort the array in ascending order using a Hybrid Sorting algorithm.\nThis hybrid algorithm uses Quick Sort, but when the size of a partition becomes smaller than a given threshold K, it switches to Insertion Sort instead of recursive Quick Sort.\nThis improves performance for nearly sorted or small partitions.\n\nInput Format\nThe first line contains two integers N and K.\nThe second line contains N space-separated integers representing the array A.\n\nOutput Format\nPrint the sorted array in ascending order.\n\nExample 1\nInput:\n10 4\n9 7 3 8 2 6 5 1 4 0\n\nOutput:\n0 1 2 3 4 5 6 7 8 9\n\nExplanation:\nQuick sort divides the array, but when partition sizes drop below K, insertion sort completes the sorting efficiently.",
      "examples": "Sample Input\n7 3\n10 4 7 1 3 9 2\n\nSample Output\n1 2 3 4 7 9 10",
      "constraints": "1 ≤ N ≤ 10^5\n1 ≤ K ≤ N\n-10^9 ≤ A[i] ≤ 10^9",
      "hints": 2,
      "timeLimit": 1,
      "memoryLimit": 256,
      "subdomainId": 2016,
      "difficulty": 3,
      "streamId": null,
      "createdByUserId": null,
      "updatedByUserId": null,

      "testCases": [
        { "id": null, "problemId": null, "input": "10 4\n9 7 3 8 2 6 5 1 4 0", "expectedOutput": "0 1 2 3 4 5 6 7 8 9", "problemTitle": "Hybrid Sorting (Quick + Insertion for Small Partitions)" },
        { "id": null, "problemId": null, "input": "7 3\n10 4 7 1 3 9 2", "expectedOutput": "1 2 3 4 7 9 10", "problemTitle": "Hybrid Sorting (Quick + Insertion for Small Partitions)" },
        { "id": null, "problemId": null, "input": "1 1\n5", "expectedOutput": "5", "problemTitle": "Hybrid Sorting (Quick + Insertion for Small Partitions)" },
        { "id": null, "problemId": null, "input": "6 2\n0 -5 8 -2 4 1", "expectedOutput": "-5 -2 0 1 4 8", "problemTitle": "Hybrid Sorting (Quick + Insertion for Small Partitions)" },
        { "id": null, "problemId": null, "input": "6 5\n6 6 6 6 6 6", "expectedOutput": "6 6 6 6 6 6", "problemTitle": "Hybrid Sorting (Quick + Insertion for Small Partitions)" }
      ],

      "starterCodes": [
        {
          "id": null,
          "problemId": null,
          "language": 1,
          "code": "def hybridSort(arr, low, high, k):\n    # TODO: Use quick sort until partition size <= k, then switch to insertion sort\n    pass\n\ndef solve():\n    n, k = map(int, input().split())\n    arr = list(map(int, input().split()))\n    hybridSort(arr, 0, n-1, k)\n    print(*arr)\n\nif __name__ == '__main__':\n    solve()",
          "problemTitle": "Hybrid Sorting (Quick + Insertion for Small Partitions)"
        },
        {
          "id": null,
          "problemId": null,
          "language": 2,
          "code": "import java.io.*;\nimport java.util.*;\n\nclass Result {\n    public static void hybridSort(int[] arr, int low, int high, int k) {\n        // TODO: Implement Quick Sort + Insertion Sort hybrid logic\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] first = br.readLine().split(\" \");\n        int n = Integer.parseInt(first[0]);\n        int k = Integer.parseInt(first[1]);\n        int[] arr = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        Result.hybridSort(arr, 0, n - 1, k);\n        for(int x : arr) System.out.print(x + \" \");\n    }\n}",
          "problemTitle": "Hybrid Sorting (Quick + Insertion for Small Partitions)"
        },
        {
          "id": null,
          "problemId": null,
          "language": 3,
          "code": "function hybridSort(arr, low, high, k) {\n    // TODO: QuickSort + switch to insertion sort when partition small\n}\n\nfunction solve(input) {\n    const lines = input.trim().split(\"\\n\");\n    const [n, k] = lines[0].split(\" \").map(Number);\n    const arr = lines[1].split(\" \").map(Number);\n    hybridSort(arr, 0, arr.length - 1, k);\n    console.log(arr.join(\" \"));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));",
          "problemTitle": "Hybrid Sorting (Quick + Insertion for Small Partitions)"
        },
        {
          "id": null,
          "problemId": null,
          "language": 4,
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid hybridSort(vector<long long>& arr, int low, int high, int k) {\n    // TODO: Combine quick sort with insertion sort based on partition size\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n, k;\n    cin >> n >> k;\n    vector<long long> arr(n);\n    for(int i = 0; i < n; i++) cin >> arr[i];\n    hybridSort(arr, 0, n-1, k);\n    for(long long x : arr) cout << x << \" \";\n    return 0;\n}",
          "problemTitle": "Hybrid Sorting (Quick + Insertion for Small Partitions)"
        },
        {
          "id": null,
          "problemId": null,
          "language": 5,
          "code": "#include <stdio.h>\n\nvoid hybridSort(long long arr[], int low, int high, int k) {\n    // TODO: Hybrid sorting implementation (Quick + Insertion)\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    long long arr[100001];\n    for(int i = 0; i < n; i++) scanf(\"%lld\", &arr[i]);\n    hybridSort(arr, 0, n-1, k);\n    for(int i = 0; i < n; i++) printf(\"%lld \", arr[i]);\n    return 0;\n}",
          "problemTitle": "Hybrid Sorting (Quick + Insertion for Small Partitions)"
        }
      ],

      "hintsList": [
        "Use quick sort normally while (high - low + 1) > K",
        "When partition size <= K, run insertion sort instead of recursion"
      ]
    },
    {
      "id": null,
      "title": "Quick Sort on Linked List",
      "description": "Problem Statement\nYou are given an integer N and a singly linked list containing N integers. Your task is to sort the linked list in ascending order using the Quick Sort algorithm.\nUnlike arrays, linked lists do not support direct indexing, making Quick Sort challenging. Instead of partitioning by swapping elements, we rearrange node pointers.\n\nInput Format\nFirst line contains an integer N.\nNext N space-separated integers represent the linked list nodes.\n\nOutput Format\nPrint the sorted linked list in ascending order.\n\nExample 1\nInput:\n6\n5 2 9 1 6 3\n\nOutput:\n1 2 3 5 6 9\n\nExplanation:\nQuick Sort partitions around a pivot (commonly last node), recursively sorting left and right sublists using pointer manipulation.",
      "examples": "Sample Input\n7\n10 4 7 1 3 9 2\n\nSample Output\n1 2 3 4 7 9 10",
      "constraints": "1 ≤ N ≤ 10^5\n-10^9 ≤ Value ≤ 10^9",
      "hints": 2,
      "timeLimit": 1,
      "memoryLimit": 256,
      "subdomainId": 2016,
      "difficulty": 3,
      "streamId": null,
      "createdByUserId": null,
      "updatedByUserId": null,

      "testCases": [
        { "id": null, "problemId": null, "input": "6\n5 2 9 1 6 3", "expectedOutput": "1 2 3 5 6 9", "problemTitle": "Quick Sort on Linked List" },
        { "id": null, "problemId": null, "input": "7\n10 4 7 1 3 9 2", "expectedOutput": "1 2 3 4 7 9 10", "problemTitle": "Quick Sort on Linked List" },
        { "id": null, "problemId": null, "input": "1\n5", "expectedOutput": "5", "problemTitle": "Quick Sort on Linked List" },
        { "id": null, "problemId": null, "input": "5\n0 -5 8 -2 4", "expectedOutput": "-5 -2 0 4 8", "problemTitle": "Quick Sort on Linked List" },
        { "id": null, "problemId": null, "input": "6\n6 6 6 6 6 6", "expectedOutput": "6 6 6 6 6 6", "problemTitle": "Quick Sort on Linked List" }
      ],

      "starterCodes": [
        {
          "id": null,
          "problemId": null,
          "language": 1,
          "code": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n# TODO: Implement Quick Sort on linked list using pointer partitioning\n\ndef quickSort(head):\n    # TODO: Return head of sorted linked list\n    return head\n\ndef solve():\n    n = int(input().strip())\n    values = list(map(int, input().split()))\n    head = Node(values[0])\n    curr = head\n    for i in range(1, n):\n        curr.next = Node(values[i])\n        curr = curr.next\n    sortedHead = quickSort(head)\n    temp = sortedHead\n    while temp:\n        print(temp.data, end=\" \")\n        temp = temp.next\n\nif __name__ == '__main__':\n    solve()",
          "problemTitle": "Quick Sort on Linked List"
        },
        {
          "id": null,
          "problemId": null,
          "language": 2,
          "code": "import java.io.*;\nimport java.util.*;\n\nclass Node {\n    int data;\n    Node next;\n    Node(int d){ data = d; next = null; }\n}\n\nclass Result {\n    public static Node quickSort(Node head) {\n        // TODO: Implement Quick Sort on linked list using pivot pointer partitioning\n        return head;\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine().trim());\n        String[] parts = br.readLine().split(\" \");\n        Node head = new Node(Integer.parseInt(parts[0]));\n        Node curr = head;\n        for(int i = 1; i < n; i++){\n            curr.next = new Node(Integer.parseInt(parts[i]));\n            curr = curr.next;\n        }\n        head = Result.quickSort(head);\n        while(head != null){\n            System.out.print(head.data + \" \");\n            head = head.next;\n        }\n    }\n}",
          "problemTitle": "Quick Sort on Linked List"
        },
        {
          "id": null,
          "problemId": null,
          "language": 3,
          "code": "class Node {\n    constructor(data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nfunction quickSort(head) {\n    // TODO: Implement Quick Sort on linked list\n    return head;\n}\n\nfunction solve(input) {\n    const lines = input.trim().split(\"\\n\");\n    const n = Number(lines[0]);\n    const arr = lines[1].split(\" \").map(Number);\n    let head = new Node(arr[0]);\n    let curr = head;\n    for(let i = 1; i < n; i++){\n        curr.next = new Node(arr[i]);\n        curr = curr.next;\n    }\n    head = quickSort(head);\n    let temp = head;\n    let result = [];\n    while(temp){ result.push(temp.data); temp = temp.next; }\n    console.log(result.join(\" \"));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));",
          "problemTitle": "Quick Sort on Linked List"
        },
        {
          "id": null,
          "problemId": null,
          "language": 4,
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    long long data;\n    Node* next;\n    Node(long long x) : data(x), next(NULL) {}\n};\n\nNode* quickSort(Node* head) {\n    // TODO: Implement Quick Sort pointer-partition for linked list\n    return head;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    long long x;\n    cin >> x;\n    Node* head = new Node(x);\n    Node* curr = head;\n    for(int i = 1; i < n; i++){\n        cin >> x;\n        curr->next = new Node(x);\n        curr = curr->next;\n    }\n    head = quickSort(head);\n    while(head){ cout << head->data << \" \"; head = head->next; }\n    return 0;\n}",
          "problemTitle": "Quick Sort on Linked List"
        },
        {
          "id": null,
          "problemId": null,
          "language": 5,
          "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    long long data;\n    struct Node* next;\n} Node;\n\nNode* quickSort(Node* head) {\n    // TODO: Implement linked list quick sort\n    return head;\n}\n\nNode* newNode(long long data){ Node* t = (Node*)malloc(sizeof(Node)); t->data = data; t->next = NULL; return t; }\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    long long x;\n    scanf(\"%lld\", &x);\n    Node* head = newNode(x);\n    Node* curr = head;\n    for(int i = 1; i < n; i++){\n        scanf(\"%lld\", &x);\n        curr->next = newNode(x);\n        curr = curr->next;\n    }\n    head = quickSort(head);\n    while(head){ printf(\"%lld \", head->data); head = head->next; }\n    return 0;\n}",
          "problemTitle": "Quick Sort on Linked List"
        }
      ],

      "hintsList": [
        "Use pointer partitioning around pivot instead of swapping values",
        "Choose last node as pivot and recursively sort left and right parts"
      ]
    },
    {
      "id": null,
      "title": "Sort by Frequency (descending frequency, value ascending)",
      "description": "Problem Statement\nYou are given an integer N and an array A containing N integers. Your task is to sort the array based on the following rules:\n1. Numbers with higher frequency should appear first (descending frequency order)\n2. If two numbers have the same frequency, the smaller number should come first (ascending value order)\nAfter sorting based on these rules, print the resulting array.\n\nInput Format\nThe first line contains an integer N.\nThe second line contains N space-separated integers representing the array A.\n\nOutput Format\nPrint the array after sorting by frequency and value rule.\n\nExample 1\nInput:\n10\n4 6 2 6 4 4 8 6 2 3\n\nOutput:\n4 4 4 6 6 6 2 2 3 8\n\nExplanation:\nFrequency → 4 appears 3 times, 6 appears 3 times, 2 appears 2 times, 3 & 8 appear once.\nBetween 4 and 6 (same frequency), 4 is smaller so comes first.",
      "examples": "Sample Input\n7\n1 3 3 1 2 2 2\n\nSample Output\n2 2 2 1 1 3 3",
      "constraints": "1 ≤ N ≤ 10^5\n-10^9 ≤ A[i] ≤ 10^9",
      "hints": 2,
      "timeLimit": 1,
      "memoryLimit": 256,
      "subdomainId": 2016,
      "difficulty": 3,
      "streamId": null,
      "createdByUserId": null,
      "updatedByUserId": null,

      "testCases": [
        { "id": null, "problemId": null, "input": "10\n4 6 2 6 4 4 8 6 2 3", "expectedOutput": "4 4 4 6 6 6 2 2 3 8", "problemTitle": "Sort by Frequency (descending frequency, value ascending)" },
        { "id": null, "problemId": null, "input": "7\n1 3 3 1 2 2 2", "expectedOutput": "2 2 2 1 1 3 3", "problemTitle": "Sort by Frequency (descending frequency, value ascending)" },
        { "id": null, "problemId": null, "input": "1\n5", "expectedOutput": "5", "problemTitle": "Sort by Frequency (descending frequency, value ascending)" },
        { "id": null, "problemId": null, "input": "6\n9 9 9 1 1 2", "expectedOutput": "9 9 9 1 1 2", "problemTitle": "Sort by Frequency (descending frequency, value ascending)" },
        { "id": null, "problemId": null, "input": "8\n7 7 8 8 6 6 6 7", "expectedOutput": "6 6 6 7 7 7 8 8", "problemTitle": "Sort by Frequency (descending frequency, value ascending)" }
      ],

      "starterCodes": [
        {
          "id": null,
          "problemId": null,
          "language": 1,
          "code": "def sortByFrequency(arr):\n    # TODO: Count frequencies, then sort by (-frequency, value)\n    return arr\n\ndef solve():\n    n = int(input().strip())\n    arr = list(map(int, input().split()))\n    result = sortByFrequency(arr)\n    print(*result)\n\nif __name__ == '__main__':\n    solve()",
          "problemTitle": "Sort by Frequency (descending frequency, value ascending)"
        },
        {
          "id": null,
          "problemId": null,
          "language": 2,
          "code": "import java.io.*;\nimport java.util.*;\n\nclass Result {\n    public static int[] sortByFrequency(int[] arr) {\n        // TODO: Count frequencies and sort using comparator\n        return arr;\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine().trim());\n        int[] arr = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        arr = Result.sortByFrequency(arr);\n        for(int x : arr) System.out.print(x + \" \");\n    }\n}",
          "problemTitle": "Sort by Frequency (descending frequency, value ascending)"
        },
        {
          "id": null,
          "problemId": null,
          "language": 3,
          "code": "function sortByFrequency(arr) {\n    // TODO: Map frequencies then sort by [-freq, value]\n    return arr;\n}\n\nfunction solve(input) {\n    const lines = input.trim().split(\"\\n\");\n    const arr = lines[1].split(\" \").map(Number);\n    console.log(sortByFrequency(arr).join(\" \"));\n}\n\nconst fs = require('fs');\nsolve(fs.readFileSync(0, 'utf-8'));",
          "problemTitle": "Sort by Frequency (descending frequency, value ascending)"
        },
        {
          "id": null,
          "problemId": null,
          "language": 4,
          "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<long long> sortByFrequency(vector<long long> arr) {\n    // TODO: Count frequency and sort based on custom comparator\n    return arr;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int n; cin >> n;\n    vector<long long> arr(n);\n    for(int i=0;i<n;i++) cin >> arr[i];\n    arr = sortByFrequency(arr);\n    for(long long x : arr) cout << x << \" \";\n    return 0;\n}",
          "problemTitle": "Sort by Frequency (descending frequency, value ascending)"
        },
        {
          "id": null,
          "problemId": null,
          "language": 5,
          "code": "#include <stdio.h>\n\nvoid sortByFrequency(long long arr[], int n) {\n    // TODO: Compute frequencies and sort based on priority rule\n}\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    long long arr[100001];\n    for(int i = 0; i < n; i++) scanf(\"%lld\", &arr[i]);\n    sortByFrequency(arr, n);\n    for(int i = 0; i < n; i++) printf(\"%lld \", arr[i]);\n    return 0;\n}",
          "problemTitle": "Sort by Frequency (descending frequency, value ascending)"
        }
      ],

      "hintsList": [
        "Use hashmap / dictionary to count occurrences",
        "Sort using pair (frequency desc, value asc)"
      ]
    }
  ]
}
