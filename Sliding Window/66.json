{
    "problems": [
        {
            "id": null,
            "title": "Minimum Adjacent Swaps for K Consecutive Ones (Sliding Window)",
            "description": "You are given an integer array, nums, and an integer k. nums comprises of only 0's and 1's. In one move, you can choose two adjacent indices and swap their values.\nReturn the minimum number of moves required so that nums has k consecutive 1's.\n\nInput Format:\nFirst line: two integers n and k.\nSecond line: n space-separated integers.\n\nOutput Format:\nPrint a single integer: the minimum number of moves.",
            "examples": "Sample Input\n6 2\n1 0 0 1 0 1\n\nSample Output\n1\n\nExplanation: Swap 1 at index 3 with 0 at index 2 -> [1,0,1,0,0,1]. Then swap 1 at index 2 with 0 at index 1 -> [1,1,0,0,0,1]. Wait, explanation says 1 move: [1,0,0,0,1,1] is also valid.",
            "constraints": "1 <= nums.length <= 10^5\nnums[i] is 0 or 1.\n1 <= k <= sum(nums)",
            "hints": 3,
            "timeLimit": 1,
            "memoryLimit": 256,
            "subdomainId": 5033,
            "difficulty": 2,
            "testCases": [
                {
                    "input": "6 2\n1 0 0 1 0 1",
                    "expectedOutput": "1"
                },
                {
                    "input": "8 3\n1 0 0 0 0 0 1 1",
                    "expectedOutput": "5"
                },
                {
                    "input": "4 2\n1 1 0 1",
                    "expectedOutput": "0"
                },
                {
                    "input": "24 6\n0 0 0 0 1 1 1 0 0 0 0 0 0 1 0 1 1 1 0 1 1 0 1 0",
                    "expectedOutput": "3"
                },
                {
                    "input": "49 1\n0 0 1 0 0 1 1 0 0 1 1 0 1 1 1 0 1 0 1 0 1 1 0 1 0 1 1 1 0 0 1 1 1 1 1 0 1 0 0 0 1 0 0 0 0 0 0 0 0",
                    "expectedOutput": "0"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def minMoves(self, nums, k):\n        # TODO: Return the minimum number of moves\n        pass\n\nif __name__ == '__main__':\n    n, k = map(int, input().split())\n    nums = list(map(int, input().split()))\n    sol = Solution()\n    print(sol.minMoves(nums, k))"
                },
                {
                    "language": 2,
                    "code": "import java.util.*;\n\nclass Solution {\n    public int minMoves(int[] nums, int k) {\n        // TODO: Return the minimum number of moves\n        return 0;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        int[] nums = new int[n];\n        for(int i=0; i<n; i++) nums[i] = sc.nextInt();\n        Solution sol = new Solution();\n        System.out.println(sol.minMoves(nums, k));\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    minMoves(nums, k) {\n        // TODO: Return the minimum number of moves\n        return 0;\n    }\n}\n\nconst fs = require('fs');\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst [n, k] = input[0].split(' ').map(Number);\nconst nums = input[1].split(' ').map(Number);\nconst sol = new Solution();\nconsole.log(sol.minMoves(nums, k));"
                },
                {
                    "language": 4,
                    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minMoves(vector<int>& nums, int k) {\n        // TODO: Return the minimum number of moves\n        return 0;\n    }\n};\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> nums(n);\n    for(int i=0; i<n; i++) cin >> nums[i];\n    Solution sol;\n    cout << sol.minMoves(nums, k) << endl;\n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint minMoves(int* nums, int numsSize, int k) {\n    // TODO: Return the minimum number of moves\n    return 0;\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    int* nums = (int*)malloc(n * sizeof(int));\n    for(int i=0; i<n; i++) scanf(\"%d\", &nums[i]);\n    printf(\"%d\\n\", minMoves(nums, n, k));\n    free(nums);\n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Collect the indices of all 1s.",
                "Transform the problem to finding k indices such that the sum of distances to their median is minimized.",
                "Use a sliding window on the indices array."
            ]
        }
    ]
}