{
    "problems": [
        {
            "id": null,
            "title": "Redundant Connection II (Union Find)",
            "description": "In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\n\nThe given input is a directed graph that started as a rooted tree with n nodes (with distinct values from 1 to n), with one additional directed edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed.\n\nThe resulting graph is given as a 2D-array of edges. Each element of edges is a pair [ui, vi] that represents a directed edge connecting nodes ui and vi, where ui is a parent of child vi.\n\nReturn an edge that can be removed so that the resulting graph is a rooted tree of n nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.\n\nInput Format:\nFirst line contains an integer n (number of edges, which equals number of nodes).\nNext n lines contain two integers ui and vi representing a directed edge from ui to vi.\n\nOutput Format:\nPrint two space-separated integers representing the edge to be removed [u, v].",
            "examples": "Sample Input 1\n3\n1 2\n1 3\n2 3\n\nSample Output 1\n2 3\n\nExplanation:\nNode 3 has two parents (1 and 2). Removing edge [2,3] makes it a valid rooted tree.\n\nSample Input 2\n5\n1 2\n2 3\n3 4\n4 1\n1 5\n\nSample Output 2\n4 1\n\nExplanation:\nThere is a cycle: 1->2->3->4->1. Removing edge [4,1] breaks the cycle and creates a valid rooted tree.",
            "constraints": "3 <= n <= 1000\n1 <= ui, vi <= n\nui != vi",
            "hints": 3,
            "timeLimit": 2,
            "memoryLimit": 256,
            "subdomainId": 7035,
            "difficulty": 3,
            "testCases": [
                {
                    "input": "3\n1 2\n1 3\n2 3",
                    "expectedOutput": "2 3"
                },
                {
                    "input": "5\n1 2\n2 3\n3 4\n4 1\n1 5",
                    "expectedOutput": "4 1"
                },
                {
                    "input": "4\n2 1\n3 1\n4 2\n4 3",
                    "expectedOutput": "4 3"
                },
                {
                    "input": "4\n1 2\n2 3\n3 1\n1 4",
                    "expectedOutput": "3 1"
                },
                {
                    "input": "3\n1 2\n2 3\n1 3",
                    "expectedOutput": "1 3"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def findRedundantDirectedConnection(self, edges):\n        # TODO: Find the redundant edge that should be removed\n        # Handle two cases: node with two parents, or cycle in the graph\n        return []\n\nif __name__ == '__main__':\n    n = int(input())\n    edges = []\n    for i in range(n):\n        u, v = map(int, input().split())\n        edges.append([u, v])\n    \n    sol = Solution()\n    result = sol.findRedundantDirectedConnection(edges)\n    print(result[0], result[1])"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public int[] findRedundantDirectedConnection(int[][] edges) {\n        // TODO: Find the redundant edge that should be removed\n        // Handle two cases: node with two parents, or cycle in the graph\n        return new int[]{0, 0};\n    }\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        int[][] edges = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            edges[i][0] = sc.nextInt();\n            edges[i][1] = sc.nextInt();\n        }\n        \n        Solution sol = new Solution();\n        int[] result = sol.findRedundantDirectedConnection(edges);\n        System.out.println(result[0] + \" \" + result[1]);\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    findRedundantDirectedConnection(edges) {\n        // TODO: Find the redundant edge that should be removed\n        // Handle two cases: node with two parents, or cycle in the graph\n        return [0, 0];\n    }\n}\n\nfunction solveProblem(input) {\n    const lines = input.trim().split('\\n');\n    const n = parseInt(lines[0]);\n    \n    const edges = [];\n    for (let i = 1; i <= n; i++) {\n        const [u, v] = lines[i].split(' ').map(Number);\n        edges.push([u, v]);\n    }\n    \n    const sol = new Solution();\n    const result = sol.findRedundantDirectedConnection(edges);\n    console.log(result[0] + ' ' + result[1]);\n}\n\nconst fs = require('fs');\nsolveProblem(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\n        // TODO: Find the redundant edge that should be removed\n        // Handle two cases: node with two parents, or cycle in the graph\n        return {0, 0};\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<vector<int>> edges(n, vector<int>(2));\n    for (int i = 0; i < n; i++) {\n        cin >> edges[i][0] >> edges[i][1];\n    }\n    \n    Solution sol;\n    vector<int> result = sol.findRedundantDirectedConnection(edges);\n    cout << result[0] << \" \" << result[1] << endl;\n    \n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid findRedundantDirectedConnection(int** edges, int n, int* result) {\n    // TODO: Find the redundant edge that should be removed\n    // Handle two cases: node with two parents, or cycle in the graph\n    result[0] = 0;\n    result[1] = 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int** edges = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        edges[i] = (int*)malloc(2 * sizeof(int));\n        scanf(\"%d %d\", &edges[i][0], &edges[i][1]);\n    }\n    \n    int result[2];\n    findRedundantDirectedConnection(edges, n, result);\n    printf(\"%d %d\\n\", result[0], result[1]);\n    \n    for (int i = 0; i < n; i++) {\n        free(edges[i]);\n    }\n    free(edges);\n    \n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Check if any node has two parents. If so, one of those two edges is the answer.",
                "Use Union-Find to detect cycles. If a cycle is detected, the current edge might be the redundant one.",
                "There are three cases: (1) node with two parents and no cycle, (2) node with two parents and cycle, (3) no node with two parents but has cycle. Handle each case appropriately."
            ]
        }
    ]
}
