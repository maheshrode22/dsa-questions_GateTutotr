{
    "problems": [
        {
            "id": null,
            "title": "Is Graph Bipartite (Union Find)",
            "description": "There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n\n- There are no self-edges (graph[u] does not contain u)\n- There are no parallel edges (graph[u] does not contain duplicate values)\n- If v is in graph[u], then u is in graph[v] (the graph is undirected)\n- The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them\n\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\n\nReturn true if and only if it is bipartite.\n\nInput Format:\nFirst line contains an integer n (number of nodes).\nNext n lines: each line contains space-separated integers representing adjacent nodes for that node. If a node has no neighbors, the line will be empty or contain -1.\n\nOutput Format:\nPrint 'true' if the graph is bipartite, otherwise print 'false'.",
            "examples": "Sample Input 1\n4\n1 2 3\n0 2\n0 1 3\n0 2\n\nSample Output 1\nfalse\n\nExplanation:\nThere is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n\nSample Input 2\n4\n1 3\n0 2\n1 3\n0 2\n\nSample Output 2\ntrue\n\nExplanation:\nWe can partition the nodes into two sets: {0, 2} and {1, 3}.",
            "constraints": "1 <= n <= 100\n0 <= graph[u].length < n\n0 <= graph[u][i] <= n - 1\ngraph[u] does not contain u\nAll values of graph[u] are unique",
            "hints": 3,
            "timeLimit": 2,
            "memoryLimit": 256,
            "subdomainId": 7035,
            "difficulty": 2,
            "testCases": [
                {
                    "input": "4\n1 2 3\n0 2\n0 1 3\n0 2",
                    "expectedOutput": "false"
                },
                {
                    "input": "4\n1 3\n0 2\n1 3\n0 2",
                    "expectedOutput": "true"
                },
                {
                    "input": "1\n-1",
                    "expectedOutput": "true"
                },
                {
                    "input": "2\n1\n0",
                    "expectedOutput": "true"
                },
                {
                    "input": "3\n1 2\n0 2\n0 1",
                    "expectedOutput": "false"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def isBipartite(self, graph):\n        # TODO: Check if graph is bipartite\n        # Use BFS/DFS with 2-coloring or Union-Find\n        # Graph is bipartite if no odd-length cycle exists\n        return False\n\nif __name__ == '__main__':\n    n = int(input())\n    graph = []\n    for i in range(n):\n        line = input().strip()\n        if line == '' or line == '-1':\n            graph.append([])\n        else:\n            graph.append(list(map(int, line.split())))\n    \n    sol = Solution()\n    result = sol.isBipartite(graph)\n    print('true' if result else 'false')"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public boolean isBipartite(int[][] graph) {\n        // TODO: Check if graph is bipartite\n        // Use BFS/DFS with 2-coloring or Union-Find\n        // Graph is bipartite if no odd-length cycle exists\n        return false;\n    }\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        \n        int[][] graph = new int[n][];\n        for (int i = 0; i < n; i++) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty() || line.equals(\"-1\")) {\n                graph[i] = new int[0];\n            } else {\n                String[] parts = line.split(\" \");\n                graph[i] = new int[parts.length];\n                for (int j = 0; j < parts.length; j++) {\n                    graph[i][j] = Integer.parseInt(parts[j]);\n                }\n            }\n        }\n        \n        Solution sol = new Solution();\n        boolean result = sol.isBipartite(graph);\n        System.out.println(result ? \"true\" : \"false\");\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    isBipartite(graph) {\n        // TODO: Check if graph is bipartite\n        // Use BFS/DFS with 2-coloring or Union-Find\n        // Graph is bipartite if no odd-length cycle exists\n        return false;\n    }\n}\n\nfunction solveProblem(input) {\n    const lines = input.trim().split('\\n');\n    const n = parseInt(lines[0]);\n    \n    const graph = [];\n    for (let i = 1; i <= n; i++) {\n        const line = lines[i].trim();\n        if (line === '' || line === '-1') {\n            graph.push([]);\n        } else {\n            graph.push(line.split(' ').map(Number));\n        }\n    }\n    \n    const sol = new Solution();\n    const result = sol.isBipartite(graph);\n    console.log(result ? 'true' : 'false');\n}\n\nconst fs = require('fs');\nsolveProblem(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isBipartite(vector<vector<int>>& graph) {\n        // TODO: Check if graph is bipartite\n        // Use BFS/DFS with 2-coloring or Union-Find\n        // Graph is bipartite if no odd-length cycle exists\n        return false;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    cin.ignore();\n    \n    vector<vector<int>> graph(n);\n    for (int i = 0; i < n; i++) {\n        string line;\n        getline(cin, line);\n        if (line.empty() || line == \"-1\") {\n            continue;\n        }\n        istringstream iss(line);\n        int node;\n        while (iss >> node) {\n            graph[i].push_back(node);\n        }\n    }\n    \n    Solution sol;\n    bool result = sol.isBipartite(graph);\n    cout << (result ? \"true\" : \"false\") << endl;\n    \n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool isBipartite(int** graph, int* graphSizes, int n) {\n    // TODO: Check if graph is bipartite\n    // Use BFS/DFS with 2-coloring or Union-Find\n    // Graph is bipartite if no odd-length cycle exists\n    return false;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\\n\", &n);\n    \n    int** graph = (int**)malloc(n * sizeof(int*));\n    int* graphSizes = (int*)malloc(n * sizeof(int));\n    \n    for (int i = 0; i < n; i++) {\n        char line[1000];\n        fgets(line, sizeof(line), stdin);\n        \n        if (strcmp(line, \"\\n\") == 0 || strcmp(line, \"-1\\n\") == 0) {\n            graph[i] = NULL;\n            graphSizes[i] = 0;\n        } else {\n            graph[i] = (int*)malloc(100 * sizeof(int));\n            int count = 0;\n            char* token = strtok(line, \" \\n\");\n            while (token != NULL) {\n                graph[i][count++] = atoi(token);\n                token = strtok(NULL, \" \\n\");\n            }\n            graphSizes[i] = count;\n        }\n    }\n    \n    bool result = isBipartite(graph, graphSizes, n);\n    printf(\"%s\\n\", result ? \"true\" : \"false\");\n    \n    for (int i = 0; i < n; i++) {\n        if (graph[i] != NULL) free(graph[i]);\n    }\n    free(graph);\n    free(graphSizes);\n    \n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Use BFS or DFS to color the graph with two colors. Start from each unvisited node and try to color it and its neighbors with alternating colors.",
                "If at any point you try to color a node with a color different from what it already has, the graph is not bipartite.",
                "Alternatively, use Union-Find: for each node, union all its neighbors together. If a node and any of its neighbors are in the same set, it's not bipartite."
            ]
        }
    ]
}
