{
    "problems": [
        {
            "id": null,
            "title": "Most Stones Removed with Same Row or Column (Union Find)",
            "description": "On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.\n\nA stone can be removed if it shares either the same row or the same column as another stone that has not been removed.\n\nGiven an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.\n\nInput Format:\nFirst line contains an integer n (number of stones).\nNext n lines contain two integers xi and yi representing the coordinates of each stone.\n\nOutput Format:\nPrint a single integer representing the maximum number of stones that can be removed.",
            "examples": "Sample Input 1\n6\n0 0\n0 1\n1 0\n1 2\n2 1\n2 2\n\nSample Output 1\n5\n\nExplanation:\nOne way to remove 5 stones: remove [2,2], [2,1], [1,2], [1,0], [0,1]. Stone [0,0] remains.\n\nSample Input 2\n5\n0 0\n0 2\n1 1\n2 0\n2 2\n\nSample Output 2\n3\n\nExplanation:\nOne way to remove 3 stones: remove [2,2], [2,0], [0,2]. Stones [0,0] and [1,1] remain.",
            "constraints": "1 <= stones.length <= 1000\n0 <= xi, yi <= 10000\nNo two stones are at the same coordinate point",
            "hints": 3,
            "timeLimit": 2,
            "memoryLimit": 256,
            "subdomainId": 7035,
            "difficulty": 3,
            "testCases": [
                {
                    "input": "6\n0 0\n0 1\n1 0\n1 2\n2 1\n2 2",
                    "expectedOutput": "5"
                },
                {
                    "input": "5\n0 0\n0 2\n1 1\n2 0\n2 2",
                    "expectedOutput": "3"
                },
                {
                    "input": "1\n0 0",
                    "expectedOutput": "0"
                },
                {
                    "input": "2\n0 0\n1 1",
                    "expectedOutput": "0"
                },
                {
                    "input": "3\n0 0\n0 1\n0 2",
                    "expectedOutput": "2"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def removeStones(self, stones):\n        # TODO: Find maximum number of stones that can be removed\n        # Use Union-Find to group stones by row or column\n        # Answer is total stones - number of connected components\n        return 0\n\nif __name__ == '__main__':\n    n = int(input())\n    stones = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        stones.append([x, y])\n    \n    sol = Solution()\n    print(sol.removeStones(stones))"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public int removeStones(int[][] stones) {\n        // TODO: Find maximum number of stones that can be removed\n        // Use Union-Find to group stones by row or column\n        // Answer is total stones - number of connected components\n        return 0;\n    }\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        int[][] stones = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            stones[i][0] = sc.nextInt();\n            stones[i][1] = sc.nextInt();\n        }\n        \n        Solution sol = new Solution();\n        System.out.println(sol.removeStones(stones));\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    removeStones(stones) {\n        // TODO: Find maximum number of stones that can be removed\n        // Use Union-Find to group stones by row or column\n        // Answer is total stones - number of connected components\n        return 0;\n    }\n}\n\nfunction solveProblem(input) {\n    const lines = input.trim().split('\\n');\n    const n = parseInt(lines[0]);\n    const stones = [];\n    for (let i = 1; i <= n; i++) {\n        const [x, y] = lines[i].split(' ').map(Number);\n        stones.push([x, y]);\n    }\n    \n    const sol = new Solution();\n    console.log(sol.removeStones(stones));\n}\n\nconst fs = require('fs');\nsolveProblem(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int removeStones(vector<vector<int>>& stones) {\n        // TODO: Find maximum number of stones that can be removed\n        // Use Union-Find to group stones by row or column\n        // Answer is total stones - number of connected components\n        return 0;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<vector<int>> stones(n, vector<int>(2));\n    for (int i = 0; i < n; i++) {\n        cin >> stones[i][0] >> stones[i][1];\n    }\n    \n    Solution sol;\n    cout << sol.removeStones(stones) << endl;\n    \n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint removeStones(int** stones, int n) {\n    // TODO: Find maximum number of stones that can be removed\n    // Use Union-Find to group stones by row or column\n    // Answer is total stones - number of connected components\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int** stones = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        stones[i] = (int*)malloc(2 * sizeof(int));\n        scanf(\"%d %d\", &stones[i][0], &stones[i][1]);\n    }\n    \n    printf(\"%d\\n\", removeStones(stones, n));\n    \n    for (int i = 0; i < n; i++) {\n        free(stones[i]);\n    }\n    free(stones);\n    \n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Think of stones as nodes. Two stones are connected if they share the same row or column. Use Union-Find to group connected stones.",
                "Each connected component can be reduced to 1 stone (the last remaining stone in that component).",
                "The answer is: total number of stones - number of connected components."
            ]
        }
    ]
}
