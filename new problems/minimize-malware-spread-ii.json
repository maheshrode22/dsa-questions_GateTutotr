{
    "problems": [
        {
            "id": null,
            "title": "Minimize Malware Spread II (Union Find)",
            "description": "You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.\n\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\n\nSuppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.\n\nWe will remove exactly one node from initial, completely removing it and any connections from this node to any other node.\n\nReturn the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\n\nInput Format:\nFirst line contains an integer n (number of nodes).\nNext n lines contain n space-separated integers (0 or 1) representing the adjacency matrix.\nNext line contains integer k (number of initially infected nodes).\nNext line contains k space-separated integers representing initially infected nodes.\n\nOutput Format:\nPrint a single integer representing the node to remove.",
            "examples": "Sample Input 1\n3\n1 1 0\n1 1 0\n0 0 1\n2\n0 1\n\nSample Output 1\n0\n\nExplanation:\nRemoving node 0 completely (and its connections) minimizes the spread.\n\nSample Input 2\n3\n1 1 0\n1 1 1\n0 1 1\n2\n0 1\n\nSample Output 2\n1\n\nExplanation:\nRemoving node 1 completely (and its connections) minimizes the spread.",
            "constraints": "2 <= n <= 300\ngraph[i][j] is 0 or 1\ngraph[i][j] == graph[j][i]\ngraph[i][i] == 1\n1 <= initial.length < n\n0 <= initial[i] <= n - 1\nAll integers in initial are unique",
            "hints": 3,
            "timeLimit": 2,
            "memoryLimit": 256,
            "subdomainId": 7035,
            "difficulty": 3,
            "testCases": [
                {
                    "input": "3\n1 1 0\n1 1 0\n0 0 1\n2\n0 1",
                    "expectedOutput": "0"
                },
                {
                    "input": "3\n1 1 0\n1 1 1\n0 1 1\n2\n0 1",
                    "expectedOutput": "1"
                },
                {
                    "input": "4\n1 1 0 0\n1 1 1 0\n0 1 1 1\n0 0 1 1\n2\n0 1",
                    "expectedOutput": "1"
                },
                {
                    "input": "2\n1 1\n1 1\n1\n0",
                    "expectedOutput": "0"
                },
                {
                    "input": "4\n1 0 0 0\n0 1 0 0\n0 0 1 0\n0 0 0 1\n2\n0 2",
                    "expectedOutput": "0"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def minMalwareSpread(self, graph, initial):\n        # TODO: Find which node to remove to minimize malware spread\n        # Simulate removing each infected node and calculate resulting spread\n        # Return the node whose removal minimizes infection count\n        return 0\n\nif __name__ == '__main__':\n    n = int(input())\n    graph = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        graph.append(row)\n    \n    k = int(input())\n    initial = list(map(int, input().split()))\n    \n    sol = Solution()\n    print(sol.minMalwareSpread(graph, initial))"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        // TODO: Find which node to remove to minimize malware spread\n        // Simulate removing each infected node and calculate resulting spread\n        // Return the node whose removal minimizes infection count\n        return 0;\n    }\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        int[][] graph = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                graph[i][j] = sc.nextInt();\n            }\n        }\n        \n        int k = sc.nextInt();\n        int[] initial = new int[k];\n        for (int i = 0; i < k; i++) {\n            initial[i] = sc.nextInt();\n        }\n        \n        Solution sol = new Solution();\n        System.out.println(sol.minMalwareSpread(graph, initial));\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    minMalwareSpread(graph, initial) {\n        // TODO: Find which node to remove to minimize malware spread\n        // Simulate removing each infected node and calculate resulting spread\n        // Return the node whose removal minimizes infection count\n        return 0;\n    }\n}\n\nfunction solveProblem(input) {\n    const lines = input.trim().split('\\n');\n    const n = parseInt(lines[0]);\n    \n    const graph = [];\n    for (let i = 1; i <= n; i++) {\n        graph.push(lines[i].split(' ').map(Number));\n    }\n    \n    const k = parseInt(lines[n + 1]);\n    const initial = lines[n + 2].split(' ').map(Number);\n    \n    const sol = new Solution();\n    console.log(sol.minMalwareSpread(graph, initial));\n}\n\nconst fs = require('fs');\nsolveProblem(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {\n        // TODO: Find which node to remove to minimize malware spread\n        // Simulate removing each infected node and calculate resulting spread\n        // Return the node whose removal minimizes infection count\n        return 0;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<vector<int>> graph(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> graph[i][j];\n        }\n    }\n    \n    int k;\n    cin >> k;\n    vector<int> initial(k);\n    for (int i = 0; i < k; i++) {\n        cin >> initial[i];\n    }\n    \n    Solution sol;\n    cout << sol.minMalwareSpread(graph, initial) << endl;\n    \n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint minMalwareSpread(int** graph, int n, int* initial, int k) {\n    // TODO: Find which node to remove to minimize malware spread\n    // Simulate removing each infected node and calculate resulting spread\n    // Return the node whose removal minimizes infection count\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int** graph = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        graph[i] = (int*)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &graph[i][j]);\n        }\n    }\n    \n    int k;\n    scanf(\"%d\", &k);\n    int* initial = (int*)malloc(k * sizeof(int));\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d\", &initial[i]);\n    }\n    \n    printf(\"%d\\n\", minMalwareSpread(graph, n, initial, k));\n    \n    for (int i = 0; i < n; i++) {\n        free(graph[i]);\n    }\n    free(graph);\n    free(initial);\n    \n    return 0;\n}"
                }
            ],
            "hintsList": [
                "For each initially infected node, simulate removing it completely (and all its connections) from the graph.",
                "Use BFS/DFS to calculate how many nodes get infected from the remaining initially infected nodes.",
                "Choose the node whose removal results in the minimum infection count. If there's a tie, return the smallest index."
            ]
        }
    ]
}
