{
    "problems": [
        {
            "id": null,
            "title": "Swim in Rising Water (Union Find)",
            "description": "You are given an n x n integer matrix grid where each value grid[i][j] represents the elevation at that point (i, j).\n\nThe rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\nReturn the least time until you can reach the bottom right square (n - 1, n - 1) if you start at the top left square (0, 0).\n\nInput Format:\nFirst line contains an integer n (size of grid).\nNext n lines contain n space-separated integers representing the grid.\n\nOutput Format:\nPrint a single integer representing the minimum time to reach bottom-right from top-left.",
            "examples": "Sample Input 1\n2\n0 2\n1 3\n\nSample Output 1\n3\n\nExplanation:\nAt time 0, you are at (0,0). You cannot move because adjacent cells have elevation > 0. At time 3, all cells are accessible, so you can reach (1,1).\n\nSample Input 2\n5\n0 1 2 3 4\n24 23 22 21 5\n12 13 14 15 16\n11 17 18 19 20\n10 9 8 7 6\n\nSample Output 2\n16\n\nExplanation:\nWe need to wait until time 16 so that (0,0) and (4,4) are connected through cells with elevation <= 16.",
            "constraints": "1 <= n <= 50\n0 <= grid[i][j] < n^2\nEach value grid[i][j] is unique",
            "hints": 3,
            "timeLimit": 2,
            "memoryLimit": 256,
            "subdomainId": 7035,
            "difficulty": 3,
            "testCases": [
                {
                    "input": "2\n0 2\n1 3",
                    "expectedOutput": "3"
                },
                {
                    "input": "5\n0 1 2 3 4\n24 23 22 21 5\n12 13 14 15 16\n11 17 18 19 20\n10 9 8 7 6",
                    "expectedOutput": "16"
                },
                {
                    "input": "1\n0",
                    "expectedOutput": "0"
                },
                {
                    "input": "3\n0 1 2\n7 6 5\n8 3 4",
                    "expectedOutput": "6"
                },
                {
                    "input": "2\n0 1\n2 3",
                    "expectedOutput": "3"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def swimInWater(self, grid):\n        # TODO: Find minimum time to reach bottom-right from top-left\n        # Use binary search on time + Union-Find or Dijkstra's algorithm\n        # At time t, connect all cells with elevation <= t\n        return 0\n\nif __name__ == '__main__':\n    n = int(input())\n    grid = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    sol = Solution()\n    print(sol.swimInWater(grid))"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public int swimInWater(int[][] grid) {\n        // TODO: Find minimum time to reach bottom-right from top-left\n        // Use binary search on time + Union-Find or Dijkstra's algorithm\n        // At time t, connect all cells with elevation <= t\n        return 0;\n    }\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        int[][] grid = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                grid[i][j] = sc.nextInt();\n            }\n        }\n        \n        Solution sol = new Solution();\n        System.out.println(sol.swimInWater(grid));\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    swimInWater(grid) {\n        // TODO: Find minimum time to reach bottom-right from top-left\n        // Use binary search on time + Union-Find or Dijkstra's algorithm\n        // At time t, connect all cells with elevation <= t\n        return 0;\n    }\n}\n\nfunction solveProblem(input) {\n    const lines = input.trim().split('\\n');\n    const n = parseInt(lines[0]);\n    \n    const grid = [];\n    for (let i = 1; i <= n; i++) {\n        grid.push(lines[i].split(' ').map(Number));\n    }\n    \n    const sol = new Solution();\n    console.log(sol.swimInWater(grid));\n}\n\nconst fs = require('fs');\nsolveProblem(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int swimInWater(vector<vector<int>>& grid) {\n        // TODO: Find minimum time to reach bottom-right from top-left\n        // Use binary search on time + Union-Find or Dijkstra's algorithm\n        // At time t, connect all cells with elevation <= t\n        return 0;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<vector<int>> grid(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> grid[i][j];\n        }\n    }\n    \n    Solution sol;\n    cout << sol.swimInWater(grid) << endl;\n    \n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint swimInWater(int** grid, int n) {\n    // TODO: Find minimum time to reach bottom-right from top-left\n    // Use binary search on time + Union-Find or Dijkstra's algorithm\n    // At time t, connect all cells with elevation <= t\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int** grid = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        grid[i] = (int*)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    printf(\"%d\\n\", swimInWater(grid, n));\n    \n    for (int i = 0; i < n; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n    \n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Use binary search on the answer (time t). For each time t, check if you can reach from (0,0) to (n-1,n-1) using only cells with elevation <= t.",
                "Use Union-Find: sort all cells by elevation, then union adjacent cells in increasing order of elevation until (0,0) and (n-1,n-1) are connected.",
                "Alternatively, use Dijkstra's algorithm where the cost is the maximum elevation encountered on the path."
            ]
        }
    ]
}
