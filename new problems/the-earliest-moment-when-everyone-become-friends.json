{
    "problems": [
        {
            "id": null,
            "title": "The Earliest Moment When Everyone Become Friends (Union Find)",
            "description": "There are n people in a social group labeled from 0 to n - 1. You are given an array logs where logs[i] = [timestampi, xi, yi] indicates that xi and yi will be friends at the time timestampi.\n\nFriendship is symmetric. That means if a is friends with b, then b is friends with a. Also, person a is acquainted with a person b if a is friends with b, or a is a friend of someone acquainted with b.\n\nReturn the earliest time for which every person became acquainted with every other person. If there is no such earliest time, return -1.\n\nInput Format:\nFirst line contains two integers: number of logs and n (number of people).\nNext lines contain three integers each: timestamp, person1, person2.\n\nOutput Format:\nPrint the earliest timestamp when everyone becomes friends, or -1 if it never happens.",
            "examples": "Sample Input 1\n8 6\n20190101 0 1\n20190104 3 4\n20190107 2 3\n20190211 1 5\n20190224 2 4\n20190301 0 3\n20190312 1 2\n20190322 4 5\n\nSample Output 1\n20190301\n\nExplanation:\nAt timestamp 20190301, after connecting 0 and 3, everyone becomes connected.\n\nSample Input 2\n5 4\n0 2 0\n1 0 1\n3 0 3\n4 1 2\n7 3 1\n\nSample Output 2\n3\n\nExplanation:\nAt timestamp 3, all people (0, 1, 2, 3) become friends.",
            "constraints": "2 <= n <= 100\n1 <= logs.length <= 10000\n0 <= timestamp <= 1000000000\n0 <= xi, yi <= n - 1\nxi != yi\nAll timestamps are unique",
            "hints": 3,
            "timeLimit": 2,
            "memoryLimit": 256,
            "subdomainId": 7035,
            "difficulty": 2,
            "testCases": [
                {
                    "input": "8 6\n20190101 0 1\n20190104 3 4\n20190107 2 3\n20190211 1 5\n20190224 2 4\n20190301 0 3\n20190312 1 2\n20190322 4 5",
                    "expectedOutput": "20190301"
                },
                {
                    "input": "5 4\n0 2 0\n1 0 1\n3 0 3\n4 1 2\n7 3 1",
                    "expectedOutput": "3"
                },
                {
                    "input": "1 2\n100 0 1",
                    "expectedOutput": "100"
                },
                {
                    "input": "2 3\n5 0 1\n10 1 2",
                    "expectedOutput": "10"
                },
                {
                    "input": "1 3\n50 0 1",
                    "expectedOutput": "-1"
                }
            ],
            "starterCodes": [
                {
                    "language": 1,
                    "code": "class Solution:\n    def earliestAcq(self, logs, n):\n        # TODO: Find earliest time when everyone becomes friends\n        # Sort logs by timestamp\n        # Use Union-Find to track connected components\n        return -1\n\nif __name__ == '__main__':\n    m, n = map(int, input().split())\n    logs = []\n    for i in range(m):\n        timestamp, x, y = map(int, input().split())\n        logs.append([timestamp, x, y])\n    \n    sol = Solution()\n    print(sol.earliestAcq(logs, n))"
                },
                {
                    "language": 2,
                    "code": "import java.io.*;\nimport java.util.*;\n\nclass Solution {\n    public int earliestAcq(int[][] logs, int n) {\n        // TODO: Find earliest time when everyone becomes friends\n        // Sort logs by timestamp\n        // Use Union-Find to track connected components\n        return -1;\n    }\n    \n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        \n        int[][] logs = new int[m][3];\n        for (int i = 0; i < m; i++) {\n            logs[i][0] = sc.nextInt();\n            logs[i][1] = sc.nextInt();\n            logs[i][2] = sc.nextInt();\n        }\n        \n        Solution sol = new Solution();\n        System.out.println(sol.earliestAcq(logs, n));\n    }\n}"
                },
                {
                    "language": 3,
                    "code": "class Solution {\n    earliestAcq(logs, n) {\n        // TODO: Find earliest time when everyone becomes friends\n        // Sort logs by timestamp\n        // Use Union-Find to track connected components\n        return -1;\n    }\n}\n\nfunction solveProblem(input) {\n    const lines = input.trim().split('\\n');\n    const [m, n] = lines[0].split(' ').map(Number);\n    const logs = [];\n    for (let i = 1; i <= m; i++) {\n        const [timestamp, x, y] = lines[i].split(' ').map(Number);\n        logs.push([timestamp, x, y]);\n    }\n    \n    const sol = new Solution();\n    console.log(sol.earliestAcq(logs, n));\n}\n\nconst fs = require('fs');\nsolveProblem(fs.readFileSync(0, 'utf-8'));"
                },
                {
                    "language": 4,
                    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int earliestAcq(vector<vector<int>>& logs, int n) {\n        // TODO: Find earliest time when everyone becomes friends\n        // Sort logs by timestamp\n        // Use Union-Find to track connected components\n        return -1;\n    }\n};\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    \n    vector<vector<int>> logs(m, vector<int>(3));\n    for (int i = 0; i < m; i++) {\n        cin >> logs[i][0] >> logs[i][1] >> logs[i][2];\n    }\n    \n    Solution sol;\n    cout << sol.earliestAcq(logs, n) << endl;\n    \n    return 0;\n}"
                },
                {
                    "language": 5,
                    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint earliestAcq(int** logs, int m, int n) {\n    // TODO: Find earliest time when everyone becomes friends\n    // Sort logs by timestamp\n    // Use Union-Find to track connected components\n    return -1;\n}\n\nint main() {\n    int m, n;\n    scanf(\"%d %d\", &m, &n);\n    \n    int** logs = (int**)malloc(m * sizeof(int*));\n    for (int i = 0; i < m; i++) {\n        logs[i] = (int*)malloc(3 * sizeof(int));\n        scanf(\"%d %d %d\", &logs[i][0], &logs[i][1], &logs[i][2]);\n    }\n    \n    printf(\"%d\\n\", earliestAcq(logs, m, n));\n    \n    for (int i = 0; i < m; i++) {\n        free(logs[i]);\n    }\n    free(logs);\n    \n    return 0;\n}"
                }
            ],
            "hintsList": [
                "Sort the logs by timestamp in ascending order. Process friendships in chronological order.",
                "Use Union-Find to track connected components. Start with n separate components (one per person).",
                "After each union operation, check if the number of components is 1. If yes, return the current timestamp."
            ]
        }
    ]
}
